Here is an overview of the entire project for your context:

Phase 0:

M0 - environment_foundation

**Purpose:**

Lock in the actual environment & runtimes.

- Define:

- MC 1.7.10 + Forge 10.13.4.1614 + GTNH 2.8.1 run profile

- Decision: external bot client vs in-process Forge mod with IPC

- Hardware constraints for local LLMs

- **Dependencies:** None

- **Difficulty:** ⭐

- **Scalability notes:**

- Document this in a single config file / README; future changes (new model, new server host) should not touch code.

M1 - agent_architecture_spec

**Purpose:**  
Unify Mineflayer + Voyager insights into a **single architecture spec**.

- Extract from Mineflayer:
    
    - Bot lifecycle
        
    - World model
        
    - Pathfinding
        
    - Action abstraction
        
- Extract from Voyager:
    
    - Planner → Skill library → Execution loop
        
    - Reflection & learning
        
- **Dependencies:** `M0`
    
- **Difficulty:** ⭐⭐
    
- **Scalability notes:**
    
    - Produce one canonical architecture doc: diagrams + interfaces.
        
    - This is the contract everything else conforms to.


Phase 1

M2 - llm_stack_local

**Purpose:**  
Provide reusable interfaces around local models.

- Implement:
    
    - `PlannerModel`: high-level plan generation
        
    - `CodeModel`: skill/code generation
        
    - `CriticModel`: evaluation / refinement
        
- Unified tool schema:
    
    - Input: structured state / goal
        
    - Output: JSON plan / skill spec, no direct MC calls
        
- **Dependencies:** `M1`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Centralize model loading & caching.
        
    - Make batch calls possible.
        
    - Log prompts/responses for replay.

M3 - world_semantics_gtnh

**Purpose:**  
Define GTNH tech + world understanding as **data + logic**.

- Data layer (config files):
    
    - Block categories (ores, machines, cables, etc.)
        
    - Item categories (plates, circuits, tools)
        
    - Tech states & prereqs (LV steam, MV, etc.)
        
- Logic layer (Python):
    
    - `infer_tech_state(inventory, machines)`
        
    - `suggest_next_targets(tech_state)`
        
    - `craftable_items(inventory, known_recipes)`
        
- **Dependencies:** `M1`
    
- **Difficulty:** ⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Keep recipes & categories in JSON/YAML, not code.
        
    - Cache derived graphs (like tech dependency DAGs).

M4 - virtue_lattice

**Purpose:**  
Encapsulate your Sefirot-based virtues as a reusable scoring layer.

- Define:
    
    - Virtue nodes: Efficiency, Safety, Sustainability, etc.
        
    - Configurable weights per context (e.g., early LV vs late HV)
        
- APIs:
    
    - `score_plan(plan, context) -> dict[virtue -> score]`
        
    - `compare_plans(plans, context) -> best_plan`
        
- **Dependencies:** `M3` (for context & environment semantics)
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Pure functions, stateless, easy to unit test.
        
    - Configurable weights → you can tune without code changes.

M5 - skill_registry

**Purpose:**  
Central place for skill definitions and metadata.

- Skill spec:
    
    - Name, parameters
        
    - Preconditions (what world/tech state is required)
        
    - Effects (changes in world/tech state)
        
    - Tags (e.g., mining, crafting, building)
        
- LLM interaction:
    
    - Planner only sees skill metadata, not raw code.
        
    - Skill implementations live as Python methods or small scripts.
        
- **Dependencies:** `M1`, `M3`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Skills registered via decorators or config files.
        
    - Easy to version and deprecate skills over time.

Phase 2:

M6 - bot_core_1_7_10

**Purpose:**  
Provide a stable, testable “body” that can be used by any controller.

- Capabilities:
    
    - Connect/keepalive
        
    - World tracking (chunks, entities)
        
    - Navigation (A* or similar)
        
    - Actions:
        
        - Move, jump, break block, place block, use item, interact with tile entities
            
- API:
    
    - `observe() -> RawWorldSnapshot`
        
    - `execute_action(Action) -> Result`
        
- **Dependencies:** `M0`, `M1`
    
- **Difficulty:** ⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Keep logic modular: pathfinding, inventory, world tracking as submodules.
        
    - Limit unnecessary packet decoding; cache what you can.

M7 - observation_encoding

**Purpose:**  
Map `RawWorldSnapshot` from `M6` into semantic state used by LLMs & planners.

- Functions:
    
    - `encode_for_planner(raw_snapshot, tech_state) -> JSON`
        
    - `encode_for_critic(trace) -> JSON`
        
- Uses:
    
    - `M3` (semantics)
        
    - `M4` (virtues context)
        
- **Dependencies:** `M3`, `M6`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Keep encodings compact. Summaries + key entities, not entire chunks.
        
    - Enforce stable schema to avoid breaking old skills.

Phase 3:

M8 - agent_loop_v1

**Purpose:**  
Implement the core loop: observe → plan → choose skills → act → evaluate.

- High-level algorithm:
    
    1. `state = observe()`
        
    2. `tech_state = infer_tech_state(state)`
        
    3. `plan = planner_model.call(state, tech_state, skill_registry, virtues)`
        
    4. Decompose plan into skill invocations
        
    5. Execute via `bot_core_1_7_10`
        
    6. Log result for learning (`M10`)
        
- Strict separation:
    
    - No direct packet calls here.
        
    - No GTNH-hardcoded weirdness here; that lives in `M3` and `M5`.
        
- **Dependencies:**
    
    - `M2` (LLM stack)
        
    - `M3` (world semantics)
        
    - `M4` (virtues)
        
    - `M5` (skills)
        
    - `M6` (bot core)
        
    - `M7` (observation encoding)
        
- **Difficulty:** ⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Design as a state machine with clear states (Idle, Planning, Executing, Recovering).
        
    - Rate-limit LLM calls, reuse plans until invalidated.

M9 - monitoring_and_tools

**Purpose:**  
Give you observability and a control surface before the system gaslights you.

- Features:
    
    - Structured logs (JSON)
        
    - Web or TUI dashboard:
        
        - World overview
            
        - Current plan & skills
            
        - Virtue scores
            
        - Tech state
            
    - Manual controls:
        
        - Pause, step, cancel plan, inspect memory
            
- **Dependencies:** `M8`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Central logger used by all modules.
        
    - Minimal UI first; upgrade visuals later.


Phase 4:

M10 - skill_learning

**Purpose:**  
Voyager-style learning: derive new skills from experience and refine existing ones.

- Components:
    
    - Experience buffer:
        
        - `{state, goal, plan, actions, outcomes, virtue_scores}`
            
    - LLM-based synthesizer:
        
        - Turn repeated success traces into new skill definitions
            
    - Evaluator:
        
        - Compare new vs existing skills on:
            
            - Success rate
                
            - Cost (time, resources)
                
            - Virtue scores
                
- **Dependencies:** `M8` (loop), `M2` (LLMs), `M5` (skill registry), `M4` (virtue scoring)
    
- **Difficulty:** ⭐⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Learning should be offline or scheduled, not constant.
        
    - Skills versioned and can be rolled back if regressions appear.


M11 - gtnh_curriculum_and_specialization

**Purpose:**  
Turn the generic learning agent into a **GTNH-native progression engine**.

- Define:
    
    - Curricula per phase:
        
        - Early LV goals
            
        - Steam infra goals
            
        - MV automation goals
            
    - Long-horizon projects:
        
        - Stargate, high-tier reactors, etc.
            
- The curriculum is:
    
    - A sequence of target tech states
        
    - Each with:
        
        - Reward shaping (virtue weight tweaks)
            
        - Suggested skills to prioritize / learn
            
- **Dependencies:** `M3`, `M5`, `M8`, `M10`
    
- **Difficulty:** ⭐⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Curriculum is config, not code.
        
    - Multiple curricula can be swapped (e.g. “eco base”, “speedrun”, “aesthetic build”).


Shortcut View:
# **Phase P0 — Foundations**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M0**|environment_foundation|⭐|0.5–2 days|Lock runtime, modpack, IPC choice|
|**M1**|agent_architecture_spec|⭐⭐|2–4 days|Full architecture doc|

### **Phase P0 Total:**

**Difficulty Avg:** ⭐⭐  
**Time:** ~3–6 days

---

# **Phase P1 — Offline Core Pillars (No Minecraft)**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M2**|llm_stack_local|⭐⭐–⭐⭐⭐|3–7 days|Local models, prompt tooling|
|**M3**|world_semantics_gtnh|⭐⭐⭐⭐|7–14 days|Tech tree + ontology mapping|
|**M4**|virtue_lattice|⭐⭐–⭐⭐⭐|3–6 days|Scoring/weights system|
|**M5**|skill_registry|⭐⭐–⭐⭐⭐|3–6 days|Skill definitions, metadata|

### **Phase P1 Total:**

**Difficulty Avg:** ⭐⭐⭐  
**Time:** ~2–4 weeks

---

# **Phase P2 — Minecraft Integration Layer**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M6**|bot_core_1_7_10|⭐⭐⭐⭐|2–4 weeks|Pathfinding, inventory, world tracking|
|**M7**|observation_encoding|⭐⭐–⭐⭐⭐|3–7 days|Convert raw MC data → semantic state|

### **Phase P2 Total:**

**Difficulty Avg:** ⭐⭐⭐⭐  
**Time:** ~3–5 weeks

---

# **Phase P3 — Agent Orchestration & Tooling**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M8**|agent_loop_v1|⭐⭐⭐⭐|1–2 weeks|Full observe → plan → act|
|**M9**|monitoring_and_tools|⭐⭐–⭐⭐⭐|3–7 days|Logs, dashboards, step controls|

### **Phase P3 Total:**

**Difficulty Avg:** ⭐⭐⭐⭐  
**Time:** ~2–3 weeks

---

# **Phase P4 — Learning & Specialization**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M10**|skill_learning|⭐⭐⭐⭐⭐|2–4 weeks|Voyager-style skill synthesis|
|**M11**|gtnh_curriculum_and_specialization|⭐⭐⭐⭐⭐|multi-week ongoing|Long-horizon GTNH progression logic|

### **Phase P4 Total:**

**Difficulty Avg:** ⭐⭐⭐⭐⭐  
**Time:** ~4–8+ weeks (ongoing beyond initial build)

---

# **Grand Totals (First-Pass Implementation)**

|Phase|Difficulty Avg|Total Time|
|---|---|---|
|**P0**|⭐⭐|3–6 days|
|**P1**|⭐⭐⭐|2–4 weeks|
|**P2**|⭐⭐⭐⭐|3–5 weeks|
|**P3**|⭐⭐⭐⭐|2–3 weeks|
|**P4**|⭐⭐⭐⭐⭐|4–8+ weeks|

---

File Structure:
```
.
├── bootstrap_structure.py                         # One-off script that bootstraps the repo skeleton / file structure
├── config                                         # All configuration for runtime, models, GTNH data, skills, and virtues
│   ├── curricula                                  # Curriculum configs (future M11 / learning-guided progression)
│   │   ├── aesthetic_megabase.yaml                # Curriculum for style-focused / aesthetic factory builds
│   │   ├── default_speedrun.yaml                  # Baseline progression curriculum (fast tech climb)
│   │   └── eco_factory.yaml                       # Curriculum for eco/efficiency-focused factory progression
│   ├── env.yaml                                   # Main environment profiles: hardware, modes, model choices, paths
│   ├── gtnh_blocks.generated.yaml                 # Autogenerated GTNH block metadata (from CSV/JSON ingestion)
│   ├── gtnh_blocks.yaml                           # Hand-edited / canonical block semantics overrides
│   ├── gtnh_items.generated.yaml                  # Autogenerated GTNH item metadata (mass-ingested)
│   ├── gtnh_items.yaml                            # Hand-curated item semantics (categories/materials, fixes)
│   ├── gtnh_recipes.agent.json                    # Recipes filtered/compacted for agent reasoning
│   ├── gtnh_recipes.generated.json                # Raw-ish, generated recipe dump from ingest scripts
│   ├── gtnh_recipes.json                          # Normalized recipe data for general use (pre-agent compaction)
│   ├── gtnh_tech_graph.yaml                       # Tech progression graph: nodes (tiers) + unlock relationships
│   ├── hardware.yaml                              # Hardware descriptions: GPU/CPU, VRAM limits, concurrency caps
│   ├── llm_roles.yaml                             # Role definitions for planner/critic/scribe/error-model etc.
│   ├── minecraft.yaml                             # Minecraft instance details: world paths, IPC config, versions
│   ├── models.yaml                                # Model registry: which models, quantizations, backends to use
│   ├── raw                                        # Raw GTNH data as ingested from CSV/JSON, source-of-truth inputs
│   │   ├── block.csv                              # Raw block dump from GTNH/nerd tools
│   │   ├── item.csv                               # Raw item dump from GTNH/nerd tools
│   │   ├── recipes.json                           # Raw recipes in generic JSON form
│   │   └── recipes_stacks.json                    # Recipes with explicit input/output stacks for parsing
│   ├── skill_packs                                # Grouped skill-pack configs (bundles of skills by stage)
│   │   ├── lv_core.yaml                           # LV progression skill pack (core early factory behaviors)
│   │   └── steam_age.yaml                         # Steam-age skill pack (coke ovens, boilers, tree farm basics)
│   ├── skills                                     # Individual skill definitions, each as a YAML spec
│   │   ├── basic_crafting.yaml                    # “Craft item X given inventory” base skill
│   │   ├── chop_tree.yaml                         # Tree chopping behavior specification
│   │   ├── feed_coke_ovens.yaml                   # Keep coke ovens supplied with fuel/input
│   │   ├── feed_steam_boiler.yaml                 # Manage fuel input for steam boilers
│   │   ├── maintain_coke_ovens.yaml               # Higher-level coke oven maintenance (ash removal, balance)
│   │   ├── plant_sapling.yaml                     # Replant saplings to maintain renewable wood
│   │   └── refill_water_tanks.yaml                # Refill water tanks / boilers with water
│   ├── skills_candidates                          # Draft skills not yet finalized or wired into packs
│   ├── tools                                      # Small config tooling / diagnostics
│   │   ├── print_env.py                           # Utility to dump/pretty-print env profile for debugging
│   │   └── validate_env.py                        # Validator for env.yaml + related configs (M0 sanity checks)
│   └── virtues.yaml                               # Virtue lattice config: weights, names, constraints for M4
├── docs                                           # Human-facing design docs and specs
│   ├── architecture.md                            # High-level architecture overview for GTNH_Agent (modules/phases)
│   ├── ipc_protocol_m6.md                         # IPC wire protocol spec for BotCore ↔ external world (M6)
│   ├── m6_bot_core_1_7_10.md                      # BotCore 1.7.10-specific design doc (GTNH runtime details)
│   └── phase1_integration.md                      # Notes/plan for integrating Phase 1 (M2–M5) components
├── .github                                        # CI/CD and repo automation config
│   └── workflows
│       └── ci.yml                                 # CI pipeline: run tests, linting, maybe type checks
├── .gitignore                                     # Ignore rules for Git (logs, cache, venv, build artifacts, etc.)
├── logs                                           # Runtime logs (LLM traces, error model logs, etc.) – ignored per you
│   └── llm
│       └── ...                                    # LLM trace + error model + scribe logs per run (no comments by request)
├── pyproject.toml                                 # Project metadata + dependencies + tooling config (pytest, etc.)
├── .pytest_cache                                  # pytest’s cache directory (auto-generated)
│   ├── CACHEDIR.TAG                               # Marker indicating cache directory
│   ├── .gitignore                                 # Keep cache out of git
│   ├── README.md                                  # Brief description of pytest cache format
│   └── v
│       └── cache
│           ├── lastfailed                         # Tracks last failed tests for quick reruns
│           └── nodeids                            # Cached node IDs to speed up test discovery
├── .python-version                                # Pin for Python version managers (e.g. pyenv)
├── README.md                                      # Top-level description, usage, and setup instructions
├── scripts                                        # One-off dev scripts and ingestion jobs (not library code)
│   ├── compact_recipes_for_agent.py               # Script to compact recipe graph into agent-friendly JSON
│   ├── demo_offline_agent_step.py                 # Offline demo of a single agent step (Phase 1 style)
│   ├── dev_shell.py                               # Developer REPL / scratchpad with preloaded context
│   ├── ingest_gtnh_semantics.py                   # Ingest/derive semantics from GTNH data sources
│   ├── ingest_nerd_csv_semantics.py               # Ingest semantics specifically from “nerd” CSV exports
│   ├── ingest_nerd_recipes.py                     # Convert nerd recipe dumps into internal recipe format
│   ├── smoke_error_model.py                       # Quick sanity test for error-model behavior
│   ├── smoke_llm_stack.py                         # Quick sanity test for the LLM stack wiring
│   └── smoke_scribe_model.py                      # Smoke-test the scribe/summary model
├── src                                            # Main Python package source
│   ├── agent                                      # Phase 2+ “agent shell” (runtime, loop, logging wiring)
│   │   ├── bootstrap.py                           # Inter-Phase 0–2 bootstrap: build_agent_runtime() with dummies
│   │   ├── experience.py                          # Experience + ExperienceBuffer types for episode-level logging
│   │   ├── logging_config.py                      # Central logging config (levels, handlers, formats)
│   │   ├── loop.py                                # AgentLoop stub: calls planner, builds PlanTrace, runs critic, logs
│   │   └── runtime_m6_m7.py                       # AgentRuntime binding M6 BotCore + M7 encoder + planner/critic
│   ├── agent_loop                                 # Older or orthogonal agent loop abstraction (Phase 1 scaffolding)
│   │   ├── __init__.py                            # Package marker for agent_loop
│   │   ├── loop.py                                # First-gen loop controller for plans/steps
│   │   ├── schema.py                              # Dataclasses / schemas for loop state and transitions
│   │   └── state.py                               # State containers for agent loop episodes, progress, etc.
│   ├── app                                        # App-level entrypoints / runtime wrappers
│   │   ├── __init__.py                            # Package marker for app
│   │   └── runtime.py                             # Top-level runtime wiring for a full app (e.g. CLI/TUI)
│   ├── bot_core                                   # M6: BotCore implementation & IPC client for MC 1.7.10
│   │   ├── actions.py                             # Primitive bot actions (move, mine, place, interact)
│   │   ├── collision.py                           # Collision/modeling helpers for movement & bounding boxes
│   │   ├── core.py                                # Main BotCore orchestrator; exposes observe() and act() APIs
│   │   ├── __init__.py                            # Package marker for bot_core
│   │   ├── nav                                    # Navigation subsystem (grid/pathfinding/movement)
│   │   │   ├── grid.py                            # Grid abstraction of world for pathfinding
│   │   │   ├── __init__.py                        # Package marker for nav
│   │   │   ├── mover.py                           # Low-level movement controller over grid/world
│   │   │   └── pathfinder.py                      # Actual pathfinding logic (A*, etc.)
│   │   ├── net                                    # Networking & IPC for BotCore
│   │   │   ├── client.py                          # Core network client used by BotCore
│   │   │   ├── external_client.py                 # IPC client intended for external processes (Forge mod etc.)
│   │   │   ├── __init__.py                        # Package marker for net
│   │   │   └── ipc.py                             # IPC protocol helpers (serialization, message framing)
│   │   ├── snapshot.py                            # RawWorldSnapshot / RawEntity definitions and helpers
│   │   ├── testing                                # Test helpers for BotCore
│   │   │   └── fakes.py                           # Fake BotCore implementations & dummy snapshots for tests
│   │   ├── tracing.py                             # BotCore-level tracing / debug instrumentation
│   │   └── world_tracker.py                       # Tracks dynamic world state over time from snapshots
│   ├── cli                                        # Command-line frontends for dev workflows
│   │   └── phase1_offline.py                      # CLI for Phase 1 offline planner/LLM experimentation
│   ├── curriculum                                 # Curriculum engine (M11-ish): task progression logic
│   │   ├── engine.py                              # Curriculum engine core: selects next tasks, scoring, etc.
│   │   ├── __init__.py                            # Package marker
│   │   ├── loader.py                              # Load curriculum YAMLs into in-memory objects
│   │   └── schema.py                              # Typed schemas for curricula, objectives, conditions
│   ├── env                                        # M0 environment/module: config → EnvProfile
│   │   ├── __init__.py                            # Package marker
│   │   ├── loader.py                              # load_env_profile(), validation, path resolution
│   │   └── schema.py                              # Dataclasses for env profiles (bot_mode, models, paths)
│   ├── gtnh_agent.egg-info                        # Installed-package metadata (generated by build)
│   │   ├── dependency_links.txt                   # Dependency links metadata for setuptools
│   │   ├── PKG-INFO                               # Package metadata (name/version/etc.)
│   │   ├── requires.txt                           # Runtime Python dependencies
│   │   ├── SOURCES.txt                            # Source files included in package
│   │   └── top_level.txt                          # Top-level package name(s) for distribution
│   ├── __init__.py                                # Root package marker for src/ (gtnh_agent or similar)
│   ├── integration                                # Cross-module integration utilities and tests
│   │   ├── adapters                               # Bridges between phases/modules
│   │   │   └── m0_env_to_world.py                 # Adapter from env profiles (M0) to world config / runtime
│   │   ├── episode_logging.py                     # Higher-level logging of episode traces & events
│   │   ├── __init__.py                            # Package marker for integration
│   │   ├── phase1_integration.py                  # Glue code for Phase 1 (LLM stack + skills + semantics)
│   │   ├── testing                                # Integration testing fakes & helpers
│   │   │   ├── fakes.py                           # Fake objects for integration tests (LLM, env, etc.)
│   │   │   └── __init__.py                        # Package marker
│   │   └── validators                             # Validators to keep planner/skills/virtues sane
│   │       ├── __init__.py                        # Package marker
│   │       ├── planner_guardrails.py              # Validate planner output (actions safe, structured)
│   │       ├── semantics_snapshots.py             # Validate semantics snapshots vs real world states
│   │       ├── skill_integrity.py                 # Check skill definitions and packs for consistency
│   │       └── virtue_snapshots.py                # Validate virtue evaluations over plans/traces
│   ├── learning                                   # Future learning layer (buffer, replay, evaluator, etc.)
│   │   ├── buffer.py                              # Replay buffer abstraction for experiences/samples
│   │   ├── evaluator.py                           # Evaluation utilities for models/agents
│   │   ├── __init__.py                            # Package marker
│   │   ├── manager.py                             # High-level learning manager / orchestration
│   │   ├── schema.py                              # Dataclasses for learning jobs, configs, sample types
│   │   └── synthesizer.py                         # Synthetic data generation for training / bootstrapping
│   ├── llm_stack                                  # M2: LLM backend stack and orchestration
│   │   ├── backend_llamacpp.py                    # llama.cpp-specific backend implementation
│   │   ├── backend.py                             # LLMBackend protocol + shared interface for local engines
│   │   ├── codegen.py                             # Utilities for generating code from model outputs
│   │   ├── config.py                              # LLM stack config loader/merger (from models.yaml/env)
│   │   ├── critic.py                              # CriticModel interface + glue to error models / scoring
│   │   ├── error_model.py                         # Error-model LLM interface (analyze failures)
│   │   ├── __init__.py                            # Package marker
│   │   ├── json_utils.py                          # JSON parsing/repair for structured LLM outputs
│   │   ├── log_files.py                           # Helpers for logging prompts/responses to files
│   │   ├── plan_code.py                           # Planner that outputs code-structured actions/steps
│   │   ├── planner.py                             # PlannerModel core interface + wrappers
│   │   ├── presets.py                             # Prompt/temperature/etc presets for different roles
│   │   ├── schema.py                              # Schemas for stack config, prompts, responses
│   │   ├── scribe.py                              # Scribe model (summarization / compression)
│   │   └── stack.py                               # High-level orchestration of planner/critic/scribe/error-model
│   ├── monitoring                                 # Monitoring + TUI dashboard + event bus
│   │   ├── bus.py                                 # Event bus abstraction for monitoring events
│   │   ├── controller.py                          # High-level controller for monitoring lifecycle
│   │   ├── dashboard_tui.py                       # TUI dashboard for live monitoring (probably curses/urwid, etc.)
│   │   ├── events.py                              # Event type definitions (snapshots, plans, errors)
│   │   ├── __init__.py                            # Package marker
│   │   └── logger.py                              # Monitoring-aware logger helpers
│   ├── observation                                # M7: observation encoding & world-state normalization
│   │   ├── encoder.py                             # WorldState normalization + encode_for_planner/critic (M7 core)
│   │   ├── __init__.py                            # Package marker
│   │   ├── pipeline.py                            # Planner pipeline wiring: observe → encode → planner call
│   │   ├── schema.py                              # Dataclasses for PlannerEncoding, CriticEncoding, etc.
│   │   ├── testing.py                             # Test helpers: make_minimal_snapshot, heavy snapshots, etc.
│   │   └── trace_schema.py                        # PlanTrace, TraceStep schema used by critic & experience layer
│   ├── semantics                                  # M3: semantics DB, tech graph, craftability logic
│   │   ├── cache.py                               # Caching layer for semantics/recipes to avoid recomputation
│   │   ├── categorize.py                          # Item/block categorization (by role/material)
│   │   ├── crafting.py                            # craftable_items() and recipe evaluation logic
│   │   ├── ingest                                 # Semantics ingestion pipeline
│   │   │   └── __init__.py                        # Package marker
│   │   ├── __init__.py                            # Package marker
│   │   ├── loader.py                              # Load semantics DB from config files (gtnh_* YAML/JSON)
│   │   ├── schema.py                              # Dataclasses for SemanticsDB, item/block metadata
│   │   └── tech_state.py                          # TechState utilities: transitions, inference, updates
│   ├── skills                                     # M5: skills system implementation
│   │   ├── base                                   # Concrete skill implementations (per YAML skill)
│   │   │   ├── basic_crafting.py                  # Implements basic_crafting.yaml behavior
│   │   │   ├── chop_tree.py                       # Implements chop_tree.yaml behavior
│   │   │   ├── feed_coke_ovens.py                 # Implements feed_coke_ovens.yaml behavior
│   │   │   ├── feed_steam_boiler.py               # Implements feed_steam_boiler.yaml behavior
│   │   │   ├── __init__.py                        # Package marker for base skills
│   │   │   ├── maintain_coke_ovens.py             # Implements maintain_coke_ovens.yaml behavior
│   │   │   ├── plant_sapling.py                   # Implements plant_sapling.yaml behavior
│   │   │   └── refill_water_tanks.py              # Implements refill_water_tanks.yaml behavior
│   │   ├── __init__.py                            # Package marker for skills
│   │   ├── loader.py                              # Load YAML skill definitions into code-level Skill objects
│   │   ├── packs.py                               # Assemble skill packs from individual skills
│   │   ├── registry.py                            # SkillRegistry: lookup, activation, capability checks
│   │   └── schema.py                              # Dataclasses/schemas for skills, skill packs
│   ├── spec                                       # Spec interfaces (protocols) for core subsystems
│   │   ├── agent_loop.py                          # Contracts for higher-level agent loops / episodes
│   │   ├── bot_core.py                            # Contracts for BotCore behavior (observe/act)
│   │   ├── experience.py                          # Contract for experience-related data structures
│   │   ├── __init__.py                            # Package marker
│   │   ├── llm.py                                 # Contracts for planner/critic/scribe/error models
│   │   ├── skills.py                              # Skill interfaces / contracts
│   │   └── types.py                               # Shared core types (WorldState, Observation, etc.)
│   ├── testing                                    # Shared test utilities
│   │   └── __init__.py                            # Package marker (likely to host shared fixtures later)
│   └── virtues                                    # M4: virtue lattice, metrics, and sanity checks
│       ├── explain.py                             # Human-readable explanations for virtue evaluations
│       ├── features.py                            # Feature extraction for virtue scoring
│       ├── __init__.py                            # Package marker
│       ├── lattice.py                             # Core virtue lattice model (sefirot/virtue interrelations)
│       ├── loader.py                              # Load virtues.yaml into runtime structures
│       ├── metrics.py                             # Metrics and scoring functions for plans/traces
│       ├── sanity.py                              # Sanity checks for virtue config and outputs
│       └── schema.py                              # Dataclasses for virtues, scores, constraints
├── tests                                          # Test suite for Phases 0–2 and surrounding systems
│   ├── conftest.py                                # Shared pytest fixtures and configuration
│   ├── fakes                                      # Test fakes for LLM, BotCore, skills, etc.
│   │   ├── fake_bot_core.py                       # Fake BotCore for tests (no Minecraft required)
│   │   ├── fake_llm_stack.py                      # Fake LLM stack (planner/critic/scribe/error-model)
│   │   ├── fake_skills.py                         # Fake skill implementations/registry for tests
│   │   └── __init__.py                            # Package marker
│   ├── __init__.py                                # Package marker
│   ├── test_actions.py                            # Tests for bot_core.actions primitives
│   ├── test_agent_loop_stub.py                    # Tests for AgentLoop stub (experience + critic wiring)
│   ├── test_agent_loop_v1.py                      # Tests for older agent_loop implementation (Phase 1)
│   ├── test_architecture_integration.py           # High-level architecture integration expectations
│   ├── test_bot_core_impl.py                      # Tests for core BotCore behavior
│   ├── test_env_loader.py                         # Tests for env.loader (M0 config validation)
│   ├── test_error_model_with_fake_backend.py      # Error model behavior w/ fake backend
│   ├── test_llm_stack_fake_backend.py             # LLM stack tested with fake backend
│   ├── test_m6_observe_contract.py                # Contract test for real BotCore.observe() → RawWorldSnapshot
│   ├── test_nav_pathfinder.py                     # Tests for nav.pathfinder movement logic
│   ├── test_observation_critic_encoding.py        # Tests for encode_for_critic and CriticEncoding schema
│   ├── test_observation_perf.py                   # Perf / scale tests for M7 encoding (caps, runtime)
│   ├── test_observation_pipeline.py               # Tests for observation.pipeline planner_step & friends
│   ├── test_observation_planner_encoding.py       # Tests for encode_for_planner & planner Observation
│   ├── test_observation_worldstate_normalization.py # Tests for build_world_state normalization logic
│   ├── test_p0_p1_env_bridge.py                   # Tests bridging Phase 0 env to Phase 1 components
│   ├── test_phase012_bootstrap.py                 # Inter-Phase 0–2 bootstrap test (build_agent_runtime + planner)
│   ├── test_phase0_runtime.py                     # Tests for Phase 0 runtime / env
│   ├── test_phase1_breakglass_no_plans.py         # Edge-case handling when planner can’t produce plans
│   ├── test_phase1_integration_offline.py         # Offline Phase 1 integration tests (no MC/LLM)
│   ├── test_runtime_m6_m7_smoke.py                # Smoke test for AgentRuntime (M6+M7 integration)
│   ├── test_scribe_model_with_fake_backend.py     # Scribe model behavior with fake backend
│   ├── test_semantics_caching_singleton.py        # Tests for semantics cache singleton behavior
│   ├── test_semantics_categorization.py           # Tests for item/block categorization logic
│   ├── test_semantics_craftability.py             # Tests for craftable_items and recipe logic
│   ├── test_semantics_tech_inference.py           # Tests for tech tier inference from world state
│   ├── test_semantics_tolerant_fallbacks.py       # Tests for tolerant semantics behavior on missing data
│   ├── test_semantics_with_normalized_worldstate.py # Tests semantics against normalized WorldState (M7)
│   ├── test_skill_loader.py                       # Tests for skills.loader (YAML to skill objects)
│   ├── test_skill_packs_integrity.py              # Integrity checks for skill packs (refs are valid)
│   ├── test_skill_packs.py                        # Tests for packs assembly behavior
│   ├── test_skill_registry.py                     # Tests for SkillRegistry lookups/registration
│   ├── test_virtue_compare_plans.py               # Tests comparing plans using virtues
│   ├── test_virtue_config_sanity.py               # Sanity checks for virtues.yaml config
│   ├── test_virtue_hard_constraints.py            # Tests for hard virtue constraints enforcement
│   ├── test_virtue_lattice_basic.py               # Basic virtue lattice behavior tests
│   └── test_world_tracker.py                      # Tests for bot_core.world_tracker behavior
└── tools                                          # Small CLI tools for manual experimentation
    ├── agent_demo.py                              # Phase 0–2 integration demo using Dummy* components
    ├── phase1_demo.py                             # Phase 1 demo: planner/skills/semantics without full agent
    └── smoke_botcore.py                           # Quick BotCore smoke test (net/snapshot correctness)

```

# GTNH_Agent – Project Summary up to M7

**Focus: What matters for M8 (agent loop / control)**

---

## 1. Big Picture

**Goal:**  
Build a fully local, LLM-driven Minecraft agent for **GregTech: New Horizons** that:

- Understands GTNH tech progression & recipes
    
- Plans over long horizons using curricula & virtues
    
- Acts in the game world through BotCore (M6)
    
- Learns from its own experience over time
    

You’ve completed **Phase 0, 1, and 2 integration**:

- **Phase 0:** Environment & config foundation (M0 & M1 specs)
    
- **Phase 1:** LLM stack, semantics, virtues, skills (M2–M5)
    
- **Phase 2:** Bot observation and encoding (M6 & M7)
    
- On top of that, you now have **AgentRuntime + AgentLoop** scaffolding, which is the entry point for M8.
    

M8 will be the **agent loop / control layer**:  
`observe → encode → plan → act → trace → critique → log/learn`.

---

## 2. Modules by Phase (What Exists Today)

### Phase 0 – Foundations

- **`env` (M0)**
    
    - `env.loader`, `env.schema`, `config/env.yaml`
        
    - Defines **EnvProfile**: profiles for bot mode, models, paths, hardware.
        
    - Validated by `tools/validate_env.py` and `tests/test_env_loader.py`.
        
- **`spec` (M1)**
    
    - Contracts for:
        
        - `WorldState`, `Observation` (`spec.types`)
            
        - LLM interfaces (`spec.llm`)
            
        - BotCore (`spec.bot_core`)
            
        - Skills (`spec.skills`)
            
        - Agent loop & experience (`spec.agent_loop`, `spec.experience`)
            
    - These specs anchor type expectations across modules.
        

**For M8:**  
You rely on `EnvProfile`, `Observation`, and the spec interfaces to keep the loop from turning into a blob of ad-hoc types.

---

### Phase 1 – Reasoning & Knowledge (M2–M5)

#### M2 – LLM Stack (`src/llm_stack`)

- Provides:
    
    - **`backend_llamacpp.py`, `backend.py`** – local backend interface & llama.cpp backend.
        
    - **`planner.py`, `plan_code.py`** – PlannerModel interface and code-structured planning.
        
    - **`critic.py`** – CriticModel interface (no heavy usage yet).
        
    - **`scribe.py`** – summarization/compression model.
        
    - **`error_model.py`** – analyze failures and give feedback.
        
    - **`stack.py`** – high-level orchestration of planner, critic, scribe, error model.
        
    - **`json_utils.py`** – robust JSON parsing & repair for LLM outputs.
        
- Configuration:
    
    - `config/models.yaml`, `config/llm_roles.yaml`, `config/hardware.yaml`.
        

**For M8:**  
You will mostly call **PlannerModel** via `AgentRuntime`, and _optionally_ CriticModel via `AgentLoop`. M8 does not need to know backend details.

---

#### M3 – Semantics (`src/semantics`)

- **SemanticsDB:**
    
    - Loaded via `semantics.loader` from:
        
        - `config/gtnh_items*.yaml`, `config/gtnh_blocks*.yaml`
            
        - `config/gtnh_recipes*.json`
            
        - `config/gtnh_tech_graph.yaml`
            
    - Encodes:
        
        - Item categories (e.g. “fuel”, “ore”, “circuit”)
            
        - Materials (e.g. “wood”, “iron”, “rubber”)
            
        - Recipes & craftability
            
        - Tech tiers & progression graph.
            
- **Key functions & types:**
    
    - `craftable_items(world, db)` – returns craftable actions given `WorldState`.
        
    - `TechState` – active tech tier + unlocked tiers + evidence.
        
    - Caching and tolerant fallbacks for missing semantics.
        

**For M8:**

- You get:
    
    - `TechState` from whoever maintains progression.
        
    - `SemanticsDB` from `AgentRuntime`.
        
- You treat them mostly as **read-only inputs** while planning & executing.
    

---

#### M4 – Virtues (`src/virtues`)

- Defines the **virtue lattice** (Kabbalah-inspired sefirot-as-virtues).
    
- Config loaded from `config/virtues.yaml`.
    
- Modules:
    
    - `lattice.py` – core structure / combination of virtues.
        
    - `metrics.py` – scoring plans/behaviors.
        
    - `sanity.py`, `explain.py` – config sanity & human-readable explanations.
        

**For M8:**  
Not fully wired yet. The important point:  
Virtue-related scoring should live at the **PlanTrace / episode level**, not inside low-level encoders.

---

#### M5 – Skills (`src/skills`)

- Maps **YAML skill specs** (`config/skills/*.yaml`, `skill_packs/*.yaml`) to code:
    
    - `skills.loader` – load YAML into internal Skill objects.
        
    - `skills.base.*` – concrete implementations:
        
        - `basic_crafting`, `chop_tree`, `feed_coke_ovens`, `maintain_coke_ovens`, etc.
            
    - `skills.packs` – group skills into packs (`steam_age`, `lv_core`).
        
    - `skills.registry` – registration & lookup.
        

**For M8:**  
The loop will eventually:

- Choose skills based on plan steps.
    
- Invoke them using BotCore actions.  
    Right now, M8 only needs **a seam** to pass in a skill system, not full logic.
    

---

### Phase 2 – World IO & Encoding (M6 & M7)

#### M6 – BotCore (`src/bot_core`)

- Purpose: speak to Minecraft 1.7.10 GTNH world via IPC.
    

Core pieces:

- **`core.py`** – BotCore orchestrator, defines `observe()` & `act()` style behavior.
    
- **`snapshot.py`** – defines:
    
    - `RawWorldSnapshot` – what `observe()` returns
        
    - `RawEntity` – entity-level data
        
- **`nav/`** – grid, movement, pathfinding.
    
- **`net/`** – client & IPC logic.
    
- **`world_tracker.py`** – tracks world over time.
    
- **`testing/fakes.py`** – fake BotCore for tests.
    

Status:

- Real networked BotCore is not integrated yet.
    
- Tests:
    
    - `test_m6_observe_contract.py` is **skipped** until real BotCore is available.
        
    - For now, `DummyBotCore` exists in tests & `agent.bootstrap`.
        

**For M8:**

- You must treat BotCore as a **service behind `AgentRuntime`**:
    
    - Do _not_ talk to `bot_core` directly from M8.
        
    - Use `runtime.bot_core.observe()` and the runtime’s API methods.
        

---

#### M7 – Observation Encoding (`src/observation`)

Core responsibilities:

1. **WorldState normalization**
    
    - `build_world_state(raw_snapshot: dict) -> WorldState`
        
    - Handles arbitrary raw snapshots (e.g. for semantics & testing).
        
    - Normalizes:
        
        - inventory → `{item_id, variant, count}`
            
        - machines → `{id, type, tier, extra}`
            
        - position, dimension, nearby entities, blocks of interest, context.
            
2. **Planner & Critic encodings**
    
    - Input:
        
        - `RawWorldSnapshot` (from M6)
            
        - `TechState`, `SemanticsDB` (from M3)
            
        - `context_id` (virtue / scenario context, from M4/config)
            
    - **PlannerEncoding** (for planner model):
        
        - `tech_state` (serialized TechState)
            
        - `agent` (position, dimension, orientation, on_ground)
            
        - `inventory_summary` (by item, category, material)
            
        - `machines_summary` (counts + presence of steam/LV/MV)
            
        - `nearby_entities` (filtered & distance-sorted, capped)
            
        - `env_summary` (dimension, tick, warnings/notes)
            
        - `craftable_summary` (top N craftable outputs)
            
        - `context_id`
            
        - `text_summary` (one-paragraph short NL summary)
            
    - **CriticEncoding** (for critic model):
        
        - `tech_state`
            
        - `context_id`
            
        - `plan`
            
        - `steps` (summarized TraceStep list)
            
        - `planner_observation`
            
        - `virtue_scores`
            
        - `text_summary`
            

Key functions:

- `encode_for_planner(raw_snapshot, tech_state, db, context_id) -> dict`
    
- `make_planner_observation(...) -> Observation`
    
- `encode_for_critic(trace: PlanTrace) -> dict`
    

Behavior details:

- Caps:
    
    - **nearby_entities** – capped at 16.
        
    - **craftable_summary.top_outputs** – capped at 10.
        
- Logs:
    
    - Unusual shapes in inventory/entities/machines (DEBUG level).
        
    - Timing & snapshot size in `encode_for_planner` (DEBUG).
        

Tests:

- `test_observation_planner_encoding.py`
    
- `test_observation_critic_encoding.py`
    
- `test_observation_perf.py`
    
- `test_observation_pipeline.py`
    
- `test_observation_worldstate_normalization.py`
    

**For M8:**  
M8 should never manually reconstruct world encodings.  
Use:

- `AgentRuntime` → `planner_tick()`
    
- Internally: `BotCore.observe()` → `encode_for_planner` → PlannerModel.
    

---

## 3. Runtime Integration: AgentRuntime & AgentLoop

### AgentRuntime (`src/agent/runtime_m6_m7.py`)

Purpose: glue M0/M2/M3/M6/M7 into a single service.

- Constructed via `build_agent_runtime()` in `agent.bootstrap`:
    
    - Loads env profile.
        
    - Builds:
        
        - Dummy or real BotCore (currently dummy).
            
        - SemanticsDB.
            
        - LLM stack (planner, critic stub, etc.).
            
    - Configures `context_id` (e.g. `"dev_dummy"`).
        
    - Initializes `TechState` (e.g. `active='stone_age'`).
        

Key behavior:

- `planner_tick()`:
    
    - Observes world from BotCore.
        
    - Builds planner `Observation` via M7.
        
    - Calls planner LLM.
        
    - Returns plan dict and stores latest observation.
        
- `get_latest_planner_observation()`:
    
    - Returns the last `Observation` produced.
        

Tests:

- `test_runtime_m6_m7_smoke.py`
    
- `test_phase012_bootstrap.py` (inter-phase integration test)
    
- `tools/agent_demo.py` – interactive demo.
    

**For M8:**  
You **do not** rewire any of this. You call it like:
python:
```
runtime = build_agent_runtime(...)
plan = runtime.planner_tick()
obs = runtime.get_latest_planner_observation()

```

### AgentLoop & Experience (`src/agent/loop.py`, `src/agent/experience.py`)

These are the **preparations for Phases 3 & 4**.

#### Experience

- `Experience`:
    
    - `trace: PlanTrace`
        
    - `critic_result: Optional[dict]`
        
    - `timestamp`
        
    - `episode_id`
        
    - `meta: dict` (e.g. `duration_sec`, `context_id`)
        
- `ExperienceBuffer`:
    
    - Simple append-only in-memory list.
        
    - Methods:
        
        - `add(experience)`
            
        - `last()`
            
        - `__len__`
            

#### AgentLoop

- `AgentLoopConfig`:
    
    - `enable_critic: bool` (default True)
        
    - `store_experiences: bool` (default True)
        
    - `max_planner_calls: int` (currently 1)
        
- `EpisodeResult`:
    
    - `plan: dict`
        
    - `trace: PlanTrace`
        
    - `critic_result: Optional[dict]`
        
    - `started_at`, `finished_at`
        
- `AgentLoop`:
    
    - Fields:
        
        - `runtime: AgentRuntime`
            
        - `experience_buffer: ExperienceBuffer`
            
        - `config: AgentLoopConfig`
            
        - `virtue_engine` (reserved for M4/M8)
            
        - `skills` (reserved for M5/M8)
            
    - Method:
        
        - `run_episode(episode_id: Optional[int]) -> EpisodeResult`
            

Current `run_episode` flow:

1. `plan = runtime.planner_tick()`
    
2. `obs = runtime.get_latest_planner_observation()`
    
3. Build `PlanTrace`:
    
    - `plan=plan`
        
    - `steps=[]` (no executor yet)
        
    - `tech_state` from `runtime` (best-effort)
        
    - `context_id` from `runtime.config.context_id`
        
    - `planner_payload=obs.json_payload`
        
    - `virtue_scores={}` (placeholder)
        
4. Optional critic:
    
    - If `config.enable_critic` and `runtime.critic_model` exists:
        
        - Call `encode_for_critic(trace)` → payload
            
        - `critic_model.evaluate(payload)` → `critic_result`
            
5. Create `EpisodeResult`.
    
6. If `config.store_experiences`:
    
    - Wrap into `Experience` and `experience_buffer.add()`.
        

Tests:

- `test_agent_loop_stub.py` – asserts:
    
    - `EpisodeResult` structure is sound.
        
    - ExperienceBuffer gets one entry and it holds a `PlanTrace`.
        

**For M8:**  
This is your main canvas. You will extend `AgentLoop.run_episode` (or add methods) to:

- Insert **execution**:
    
    - Turn plan steps into calls to BotCore / skills.
        
    - Populate `PlanTrace.steps` with `TraceStep` entries.
        
- Update **TechState** based on progress.
    
- Feed **virtue scores** into `PlanTrace.virtue_scores`.
    
- Grow **experience logging** beyond in-memory buffer.
    

But you do _not_ change M7 encoders or AgentRuntime wiring for this. You stay at the loop level.

---

## 4. Logging & Diagnostics

- Logging is centralized via:
    
    - `agent.logging_config` (setup)
        
    - Logging calls in:
        
        - `observation.encoder` (shape issues, timing)
            
        - LLM stack (log_files, error model traces)
            
        - Agent loop & runtime (DEBUG & WARNING for critic failures, etc.)
            

Design choices:

- **M7 logging is gated by log level**:
    
    - Shape anomalies → DEBUG.
        
    - Performance timing (`encode_for_planner`) → DEBUG.
        
- M8 & beyond should **tune logging via config**, not by editing internals.
    

---

## 5. Important Design Decisions / Changes (Relevant to M8)

1. **AgentRuntime as a Service**
    
    - M8 is **not** allowed to recreate or duplicate the wiring of:
        
        - env loading
            
        - semantics loading
            
        - LLM stack wiring
            
        - BotCore instantiation
            
        - observation encoding
            
    - Instead: `build_agent_runtime()` returns a ready-to-use service.
        
2. **Observation as API Boundary**
    
    - M7 defines what the planner “sees.”
        
    - PlannerEncoding/CriticEncoding are treated as **frozen schemas**.
        
    - Any future changes are deliberate and versioned.
        
3. **PlanTrace as the Unit of Experience**
    
    - `PlanTrace` is the canonical “episode-level object”:
        
        - plan
            
        - execution steps
            
        - tech_state
            
        - context_id
            
        - planner payload
            
        - virtue_scores
            
    - Experience, critic, virtue analysis should all use PlanTrace.
        
4. **Critic Lives at the Loop Level**
    
    - No critic logic inside:
        
        - BotCore
            
        - M7 encoders
            
        - LLM stack internals
            
    - Critic is called by **AgentLoop** using `encode_for_critic(trace)`.
        
5. **Experience Layer is Opt-In**
    
    - `ExperienceBuffer` is the first step toward a proper replay/memory system.
        
    - For now, it’s in-memory and optional.
        
    - M8+ can replace or extend it (file logging, DB, training data).
        
6. **Tests as Contracts**
    
    - Core contracts for M8:
        
        - `test_phase012_bootstrap.py` – ensures `build_agent_runtime()` + planner path works.
            
        - `test_observation_*` – locks planner/critic encodings.
            
        - `test_agent_loop_stub.py` – locks episode structure & experience logging.
            
    - If M8 breaks these, you’re violating previously agreed boundaries.
        

---

## 6. What’s Missing / Open for M8

These are gaps M8 is supposed to address, not bugs:

- **No real BotCore yet in runtime**
    
    - `DummyBotCore` used in demo and tests.
        
    - Real BotCore wiring will come later when IPC is ready.
        
- **No executor / world-changing actions in AgentLoop**
    
    - `PlanTrace.steps` is empty.
        
    - No code turns plan steps into BotCore `act()` calls.
        
- **No TechState updates in the loop**
    
    - TechState is passed into planner/critic but not updated based on actions yet.
        
- **Virtue engine not integrated**
    
    - `virtue_engine` field exists on `AgentLoop`, but isn’t used.
        
    - `virtue_scores` in `PlanTrace` is empty.
        
- **Experience persistence**
    
    - Experiences are only stored in memory.
        
    - No file/DB logging, no replay sampling.
        

---

## 7. M8: How to Use All This

When you start M8, your mental starting point should be:
python:
```
from agent.bootstrap import build_agent_runtime
from agent.loop import AgentLoop, AgentLoopConfig

runtime = build_agent_runtime(profile="dev_local", use_dummy_semantics=True)
loop = AgentLoop(runtime=runtime, config=AgentLoopConfig())

result = loop.run_episode(episode_id=1)
# result.plan       -> planner output
# result.trace      -> PlanTrace
# result.critic_result -> critic output (if any)
# loop.experience_buffer.last() -> Experience

```

**Your job in M8:**

1. **Add Execution**
    
    - Decode planner steps into skill invocations / BotCore actions.
        
    - Record each step into `TraceStep`:
        
        - action
            
        - result (success/error)
            
        - world_before/world_after (at least positions)
            
        - meta (timestamps, skill names, etc.)
            
2. **Connect Virtues**
    
    - Plug in a `virtue_engine` that:
        
        - Scores plans or traces.
            
        - Updates `trace.virtue_scores`.
            
    - Optionally feed virtue scores into the critic or future curriculum engine.
        
3. **Enrich Experience**
    
    - Add more metadata:
        
        - tech_state snapshot
            
        - curriculum context
            
        - environment profile
            
    - Decide where and how to log:
        
        - Append-only JSON logs
            
        - Future training dataset format
            
4. **Stay Within Established Boundaries**
    
    - Don’t bypass:
        
        - `encode_for_planner`
            
        - `encode_for_critic`
            
        - `AgentRuntime`’s APIs
            
    - Keep critic / experience wiring at the **AgentLoop / episode** level.




# GTNH Agent – Integration Plan for the 7 Essential Qualities
*(Architecture Expansion Document)*

This document maps each of the seven required agent qualities into the existing GTNH_Agent module structure.  
Where a quality doesn’t cleanly fit, a submodule or extension point is proposed within the appropriate module.  
Modules M0–M3 are avoided unless absolutely necessary for correctness.

---
# Recommended Implementation Order

1. Finish M4 + M5  
2. Complete M6 (functionally)  
3. Complete M7
4. Prototype M8 loop  
5. Add LLM-role separation (M2 polish)  
6. Add self-evaluation loop  (M8, M2)
7. Add hierarchical planning  (M8, M2)
8. Add experience memory  (M8, M10)
9. Add predictive world-model  (M3)
10. Add curriculum engine  (M11)
11. Add full skill evolution  (M5, M10)

---
# Overview of the Seven Qualities

1. Self-evaluation + retry loop (Reflexion)
2. Dynamic skill evolution & versioning (Voyager / SWE-Agent)
3. Hierarchical planning (AlphaStar → o-series)
4. Experience memory (Reflexion / Voyager / Mentor)
5. Curriculum-driven goal selection (Voyager / meta-agent frameworks)
6. Structured LLM-role separation (CAMEL / o-series)
7. Lightweight predictive world-model (MuZero DNA, simplified)

Each section explains:
- Where the feature fits
- What is added
- When it’s implemented relative to the phase structure

---

# 1. Self-Evaluation + Retry Loop

## Placement
- **Primary:** `M8 – agent_loop_v1`
- **Support:** `M2 – llm_stack_local` (Critic + ErrorModel), `M9 – monitoring_and_tools`

## Additions

### M8 (agent_loop)
Add a Reflexion-style sub-loop:

```
observe → encode
    → propose_plan (planner)
    → evaluate_plan (critic + virtues)
        → retry if needed
    → execute_plan
    → evaluate_outcome (error_model)
        → selective retry
    → summarize_episode
```

Dataclasses:
- `PlanAttempt`
- `PlanEvaluation`
- `RetryPolicy`

Functions:
- `evaluate_plan_with_virtues`
- `maybe_retry_plan`
- `postmortem_plan_failure`

### M2 (llm_stack)
CriticModel and ErrorModel return structured fields:
- `failure_type`
- `severity`
- `fix_suggestions`

### M9 (monitoring)
New events:
- `PlanEvaluated`
- `PlanRetried`
- `PlanAbandoned`

## Implementation Timing
After M6 is functionally complete; can be prototyped with fakes.

---

# 2. Dynamic Skill Evolution & Versioning

## Placement
- **Primary:** `M5 – skill_registry`
- **Secondary:** `M10 – skill_learning`
- **Config:** `config/skills/` + `config/skills_candidates/`

## Additions

### M5 (skill_registry)
Extend skill schema:
- `version`
- `status: active | deprecated | candidate`
- `origin: hand_authored | auto_synthesized`
- `metrics: { success_rate, avg_cost, avg_risk, last_used_at }`

Registry functions:
- `get_latest_skill`
- `list_skill_versions`
- `register_skill_candidate`
- `mark_skill_version_deprecated`

### M10 (skill_learning)
Use replay buffer + evaluator to promote/demote skill versions.

## Implementation Timing
Basic versioning immediately after M5.  
Evolution logic during M10.

---

# 3. Hierarchical Planning

## Placement
- **Primary:** `M8 – agent_loop_v1`
- **Secondary:** `M2 – planner`
- **Spec:** `spec/agent_loop.py`, `spec/skills.py`, `spec/types.py`

## Additions

### Planning Levels
1. **Goal** – long-horizon objective  
2. **Task** – mid-level decomposition  
3. **Skill** – concrete steps  
4. **Action** – BotCore primitives  

### Spec Layer
Add:
- `AgentGoal`
- `TaskPlan`
- `SkillInvocation`

### M2 (planner)
Planner modes:
- `plan_goal → tasks`
- `plan_task → skills`

### M8 (agent_loop)
Convert loop into hierarchical state machine:
- `GoalSelection → TaskPlanning → SkillResolution → Execution → Review`

## Implementation Timing
Implement before or alongside M11 (Curriculum).

---

# 4. Experience Memory

## Placement
- **Primary:** `M10 – skill_learning`
- **Hooks:** `M8 – agent_loop`, `llm_stack/scribe.py`, `M9 – monitoring`

## Additions

### Experience Schema (learning/buffer.py)
```
Experience = {
  problem_signature,
  goal,
  plan,
  attempts,
  final_outcome,
  virtue_scores,
  lessons,
}
```

Buffer methods:
- `append_experience`
- `query_similar_experiences`

### M8 (agent_loop)
At episode end:
- write Experience object to replay buffer

### Scribe (M2)
Add:
- `summarize_episode_for_memory`

## Implementation Timing
After M8 prototype loop works.  
Retrieval logic during M10.

---

# 5. Curriculum-Driven Goal Selection

## Placement
- **Primary:** `M11 – curriculum engine`
- **Integrated with:** `M8`, `M3`, `M4`

## Additions

### Curriculum Engine
Inputs:
- TechState  
- experience memory  
- virtue context  

Outputs:
- `AgentGoal`

### Curriculum Schema
Add per-unit metadata:
- `required_tech_state`
- `preferred_virtue_context`
- `entry_conditions`
- `exit_conditions`

### M8 (agent_loop)
At top of loop:
```
goal = curriculum.next_goal(tech_state)
```

## Implementation Timing
After M8 + M4 are stable (Phase 4).

---

# 6. Structured LLM-Role Separation

## Placement
- **Primary:** `M2 – llm_stack_local`
- **Config:** `config/llm_roles.yaml`
- **Spec:** `spec/llm.py`

## Additions

### Config (llm_roles.yaml)
Define for each role:
- system prompt  
- temperature  
- STOP tokens  
- output schema  
- tool permissions  

### LLMStack (M2)
Expose methods:
- `call_planner`
- `call_critic`
- `call_scribe`
- `call_error_model`

### Agent Loop
Always call with explicit role context.

## Implementation Timing
During M2 polishing, before heavy M8 integration.

---

# 7. Lightweight Predictive World-Model

## Placement
- **Primary:** `M3 – world_semantics_gtnh` (new file: `world_model.py`)
- **Used by:** `M4`, `M8`, `M11`

## Additions

### world_model.py
Functions:
```
simulate_tech_progress(...)
estimate_infra_effect(...)
estimate_resource_trajectory(...)
```

Uses:
- `TechGraph`
- `SemanticsDB`

### Integration
- M4: feed predictions into virtue scoring  
- M8: reject bad plans early  
- M11: predict long-term returns of goals  

## Implementation Timing
After M3 stabilizes; while working on M4/M11.

---

# Module Mapping Summary

| Quality | Modules |
|--------|---------|
| Self-evaluation + retry | **M8**, M2, M9 |
| Skill evolution & versioning | **M5**, M10 |
| Hierarchical planning | **M8**, M2, spec |
| Experience memory | **M10**, M8, Scribe |
| Curriculum-driven goals | **M11**, M8, M3, M4 |
| LLM-role separation | **M2**, config roles |
| Predictive world-model | **M3**, consumed by M4/M8/M11 |


Primer and old module integration prompt (upload the old module workflow with this prompt):

Within the context primer I just sent you, the filestructure and everything after it contains the most up-to-date information. Everything before should be treated as abstract, big-picture framing for the project as a whole, not gospel.

I am now attaching a file that contains the old M8 module workflow. It should be treated only as a template for how the module workflow should be structured. It should not be treated as particularly relevant in content, because it is outdated. However, my project notes rely on the standardization of this template structure.

Please superimpose the contents of the context primer onto the template structure of the old M8 module workflow. The output should be a finished, up-to-date M8 module workflow that exactly matches the structure of the old module. Its contents should not reflect those of the old M8 workflow unless absolutely necessary.

Please acknowledge and reflect what I'm asking you to do before executing.