Here is an overview of the entire project for your context:

Phase 0:

M0 - environment_foundation

**Purpose:**

Lock in the actual environment & runtimes.

- Define:

- MC 1.7.10 + Forge 10.13.4.1614 + GTNH 2.8.1 run profile

- Decision: external bot client vs in-process Forge mod with IPC

- Hardware constraints for local LLMs

- **Dependencies:** None

- **Difficulty:** ⭐

- **Scalability notes:**

- Document this in a single config file / README; future changes (new model, new server host) should not touch code.

M1 - agent_architecture_spec

**Purpose:**  
Unify Mineflayer + Voyager insights into a **single architecture spec**.

- Extract from Mineflayer:
    
    - Bot lifecycle
        
    - World model
        
    - Pathfinding
        
    - Action abstraction
        
- Extract from Voyager:
    
    - Planner → Skill library → Execution loop
        
    - Reflection & learning
        
- **Dependencies:** `M0`
    
- **Difficulty:** ⭐⭐
    
- **Scalability notes:**
    
    - Produce one canonical architecture doc: diagrams + interfaces.
        
    - This is the contract everything else conforms to.


Phase 1

M2 - llm_stack_local

**Purpose:**  
Provide reusable interfaces around local models.

- Implement:
    
    - `PlannerModel`: high-level plan generation
        
    - `CodeModel`: skill/code generation
        
    - `CriticModel`: evaluation / refinement
        
- Unified tool schema:
    
    - Input: structured state / goal
        
    - Output: JSON plan / skill spec, no direct MC calls
        
- **Dependencies:** `M1`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Centralize model loading & caching.
        
    - Make batch calls possible.
        
    - Log prompts/responses for replay.

M3 - world_semantics_gtnh

**Purpose:**  
Define GTNH tech + world understanding as **data + logic**.

- Data layer (config files):
    
    - Block categories (ores, machines, cables, etc.)
        
    - Item categories (plates, circuits, tools)
        
    - Tech states & prereqs (LV steam, MV, etc.)
        
- Logic layer (Python):
    
    - `infer_tech_state(inventory, machines)`
        
    - `suggest_next_targets(tech_state)`
        
    - `craftable_items(inventory, known_recipes)`
        
- **Dependencies:** `M1`
    
- **Difficulty:** ⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Keep recipes & categories in JSON/YAML, not code.
        
    - Cache derived graphs (like tech dependency DAGs).

M4 - virtue_lattice

**Purpose:**  
Encapsulate your Sefirot-based virtues as a reusable scoring layer.

- Define:
    
    - Virtue nodes: Efficiency, Safety, Sustainability, etc.
        
    - Configurable weights per context (e.g., early LV vs late HV)
        
- APIs:
    
    - `score_plan(plan, context) -> dict[virtue -> score]`
        
    - `compare_plans(plans, context) -> best_plan`
        
- **Dependencies:** `M3` (for context & environment semantics)
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Pure functions, stateless, easy to unit test.
        
    - Configurable weights → you can tune without code changes.

M5 - skill_registry

**Purpose:**  
Central place for skill definitions and metadata.

- Skill spec:
    
    - Name, parameters
        
    - Preconditions (what world/tech state is required)
        
    - Effects (changes in world/tech state)
        
    - Tags (e.g., mining, crafting, building)
        
- LLM interaction:
    
    - Planner only sees skill metadata, not raw code.
        
    - Skill implementations live as Python methods or small scripts.
        
- **Dependencies:** `M1`, `M3`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Skills registered via decorators or config files.
        
    - Easy to version and deprecate skills over time.

Phase 2:

M6 - bot_core_1_7_10

**Purpose:**  
Provide a stable, testable “body” that can be used by any controller.

- Capabilities:
    
    - Connect/keepalive
        
    - World tracking (chunks, entities)
        
    - Navigation (A* or similar)
        
    - Actions:
        
        - Move, jump, break block, place block, use item, interact with tile entities
            
- API:
    
    - `observe() -> RawWorldSnapshot`
        
    - `execute_action(Action) -> Result`
        
- **Dependencies:** `M0`, `M1`
    
- **Difficulty:** ⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Keep logic modular: pathfinding, inventory, world tracking as submodules.
        
    - Limit unnecessary packet decoding; cache what you can.

M7 - observation_encoding

**Purpose:**  
Map `RawWorldSnapshot` from `M6` into semantic state used by LLMs & planners.

- Functions:
    
    - `encode_for_planner(raw_snapshot, tech_state) -> JSON`
        
    - `encode_for_critic(trace) -> JSON`
        
- Uses:
    
    - `M3` (semantics)
        
    - `M4` (virtues context)
        
- **Dependencies:** `M3`, `M6`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Keep encodings compact. Summaries + key entities, not entire chunks.
        
    - Enforce stable schema to avoid breaking old skills.

Phase 3:

M8 - agent_loop_v1

**Purpose:**  
Implement the core loop: observe → plan → choose skills → act → evaluate.

- High-level algorithm:
    
    1. `state = observe()`
        
    2. `tech_state = infer_tech_state(state)`
        
    3. `plan = planner_model.call(state, tech_state, skill_registry, virtues)`
        
    4. Decompose plan into skill invocations
        
    5. Execute via `bot_core_1_7_10`
        
    6. Log result for learning (`M10`)
        
- Strict separation:
    
    - No direct packet calls here.
        
    - No GTNH-hardcoded weirdness here; that lives in `M3` and `M5`.
        
- **Dependencies:**
    
    - `M2` (LLM stack)
        
    - `M3` (world semantics)
        
    - `M4` (virtues)
        
    - `M5` (skills)
        
    - `M6` (bot core)
        
    - `M7` (observation encoding)
        
- **Difficulty:** ⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Design as a state machine with clear states (Idle, Planning, Executing, Recovering).
        
    - Rate-limit LLM calls, reuse plans until invalidated.

M9 - monitoring_and_tools

**Purpose:**  
Give you observability and a control surface before the system gaslights you.

- Features:
    
    - Structured logs (JSON)
        
    - Web or TUI dashboard:
        
        - World overview
            
        - Current plan & skills
            
        - Virtue scores
            
        - Tech state
            
    - Manual controls:
        
        - Pause, step, cancel plan, inspect memory
            
- **Dependencies:** `M8`
    
- **Difficulty:** ⭐⭐–⭐⭐⭐
    
- **Scalability/perf:**
    
    - Central logger used by all modules.
        
    - Minimal UI first; upgrade visuals later.


Phase 4:

M10 - skill_learning

**Purpose:**  
Voyager-style learning: derive new skills from experience and refine existing ones.

- Components:
    
    - Experience buffer:
        
        - `{state, goal, plan, actions, outcomes, virtue_scores}`
            
    - LLM-based synthesizer:
        
        - Turn repeated success traces into new skill definitions
            
    - Evaluator:
        
        - Compare new vs existing skills on:
            
            - Success rate
                
            - Cost (time, resources)
                
            - Virtue scores
                
- **Dependencies:** `M8` (loop), `M2` (LLMs), `M5` (skill registry), `M4` (virtue scoring)
    
- **Difficulty:** ⭐⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Learning should be offline or scheduled, not constant.
        
    - Skills versioned and can be rolled back if regressions appear.


M11 - gtnh_curriculum_and_specialization

**Purpose:**  
Turn the generic learning agent into a **GTNH-native progression engine**.

- Define:
    
    - Curricula per phase:
        
        - Early LV goals
            
        - Steam infra goals
            
        - MV automation goals
            
    - Long-horizon projects:
        
        - Stargate, high-tier reactors, etc.
            
- The curriculum is:
    
    - A sequence of target tech states
        
    - Each with:
        
        - Reward shaping (virtue weight tweaks)
            
        - Suggested skills to prioritize / learn
            
- **Dependencies:** `M3`, `M5`, `M8`, `M10`
    
- **Difficulty:** ⭐⭐⭐⭐⭐
    
- **Scalability/perf:**
    
    - Curriculum is config, not code.
        
    - Multiple curricula can be swapped (e.g. “eco base”, “speedrun”, “aesthetic build”).


Shortcut View:
# **Phase P0 — Foundations**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M0**|environment_foundation|⭐|0.5–2 days|Lock runtime, modpack, IPC choice|
|**M1**|agent_architecture_spec|⭐⭐|2–4 days|Full architecture doc|

### **Phase P0 Total:**

**Difficulty Avg:** ⭐⭐  
**Time:** ~3–6 days

---

# **Phase P1 — Offline Core Pillars (No Minecraft)**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M2**|llm_stack_local|⭐⭐–⭐⭐⭐|3–7 days|Local models, prompt tooling|
|**M3**|world_semantics_gtnh|⭐⭐⭐⭐|7–14 days|Tech tree + ontology mapping|
|**M4**|virtue_lattice|⭐⭐–⭐⭐⭐|3–6 days|Scoring/weights system|
|**M5**|skill_registry|⭐⭐–⭐⭐⭐|3–6 days|Skill definitions, metadata|

### **Phase P1 Total:**

**Difficulty Avg:** ⭐⭐⭐  
**Time:** ~2–4 weeks

---

# **Phase P2 — Minecraft Integration Layer**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M6**|bot_core_1_7_10|⭐⭐⭐⭐|2–4 weeks|Pathfinding, inventory, world tracking|
|**M7**|observation_encoding|⭐⭐–⭐⭐⭐|3–7 days|Convert raw MC data → semantic state|

### **Phase P2 Total:**

**Difficulty Avg:** ⭐⭐⭐⭐  
**Time:** ~3–5 weeks

---

# **Phase P3 — Agent Orchestration & Tooling**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M8**|agent_loop_v1|⭐⭐⭐⭐|1–2 weeks|Full observe → plan → act|
|**M9**|monitoring_and_tools|⭐⭐–⭐⭐⭐|3–7 days|Logs, dashboards, step controls|

### **Phase P3 Total:**

**Difficulty Avg:** ⭐⭐⭐⭐  
**Time:** ~2–3 weeks

---

# **Phase P4 — Learning & Specialization**

|Module|Name|Difficulty|Est. Time|Notes|
|---|---|---|---|---|
|**M10**|skill_learning|⭐⭐⭐⭐⭐|2–4 weeks|Voyager-style skill synthesis|
|**M11**|gtnh_curriculum_and_specialization|⭐⭐⭐⭐⭐|multi-week ongoing|Long-horizon GTNH progression logic|

### **Phase P4 Total:**

**Difficulty Avg:** ⭐⭐⭐⭐⭐  
**Time:** ~4–8+ weeks (ongoing beyond initial build)

---

# **Grand Totals (First-Pass Implementation)**

|Phase|Difficulty Avg|Total Time|
|---|---|---|
|**P0**|⭐⭐|3–6 days|
|**P1**|⭐⭐⭐|2–4 weeks|
|**P2**|⭐⭐⭐⭐|3–5 weeks|
|**P3**|⭐⭐⭐⭐|2–3 weeks|
|**P4**|⭐⭐⭐⭐⭐|4–8+ weeks|

---

# **Overall Estimate**

**Minimum:** ~11 weeks  
**Expected:** ~14–18 weeks  
**Ambitious agent with learning + GTNH specialization:** ~20–30 weeks ongoing refinement


File Structure:

```
.                                   # GTNH_Agent repo root; home of your increasingly cursed genius
├── bootstrap_structure.py          # One-time helper to scaffold the repo / file structure programmatically
├── config                          # All declarative config: env, models, semantics, skills, curricula, virtues
│   ├── curricula                   # High-level task flows / learning tracks for the agent (Phase 1 / M5)
│   │   ├── aesthetic_megabase.yaml # Curriculum for “aesthetic megabase” playstyle; long-horizon build goals
│   │   ├── default_speedrun.yaml   # Default general-purpose / speedrun-style curriculum for progression
│   │   └── eco_factory.yaml        # Curriculum tailored to efficient/eco base automation path
│   ├── env.yaml                    # Top-level environment profile: which env, runtime mode, debug flags, etc.
│   ├── gtnh_blocks.generated.yaml  # GENERATED: large GTNH block catalog derived from raw dumps
│   ├── gtnh_blocks.yaml            # Hand-curated / patched block metadata layered over the generated file
│   ├── gtnh_items.generated.yaml   # GENERATED: large GTNH item catalog derived from raw dumps
│   ├── gtnh_items.yaml             # Hand-authored overrides and special cases for item semantics
│   ├── gtnh_recipes.agent.json     # Recipes pruned/compacted specifically for agent reasoning & planning
│   ├── gtnh_recipes.generated.json # GENERATED: massive raw recipe graph produced by ingestion scripts
│   ├── gtnh_recipes.json           # Stable, normalized recipes used by semantics & planning
│   ├── gtnh_tech_graph.yaml        # Tech progression graph: tiers, unlock dependencies, milestones
│   ├── hardware.yaml               # Hardware profile: CPU/GPU, RAM, constraints for model loading
│   ├── llm_roles.yaml              # Descriptions & presets for planner/critic/scribe/error_model personas
│   ├── minecraft.yaml              # Minecraft connection profile: host/port, profile, world assumptions
│   ├── models.yaml                 # Catalog of locally available models and which role uses which model
│   ├── raw                         # Raw, unprocessed GTNH data dumps from tools like nerd/tellme/NEI
│   │   ├── block.csv               # Raw block list dump; source of gtnh_blocks.generated.yaml
│   │   ├── item.csv                # Raw item list dump; source of gtnh_items.generated.yaml
│   │   ├── recipes.json            # Raw recipe dump (un-compacted, noisy, mod-native format)
│   │   └── recipes_stacks.json     # Recipes with stack/quantity info; used for accurate crafting semantics
│   ├── skill_packs                 # Grouped skill sets for different progression “eras”
│   │   ├── lv_core.yaml            # Core LV skills pack: minimal skills for living in LV without suffering
│   │   └── steam_age.yaml          # Steam Age skills pack: pre-LV basics like boilers and coke ovens
│   ├── skills                      # Individual skill definitions (symbolic + parameters) for M5/M8
│   │   ├── basic_crafting.yaml     # Skill description for general table crafting flows
│   │   ├── chop_tree.yaml          # Skill for cutting trees; includes safety + expected world delta
│   │   ├── feed_coke_ovens.yaml    # Skill for refueling coke ovens with wood/charcoal/etc.
│   │   ├── feed_steam_boiler.yaml  # Skill for feeding solid fuel boilers (coal/coke/charcoal)
│   │   ├── maintain_coke_ovens.yaml# Skill for long-term maintenance: pulling outputs, refilling inputs
│   │   ├── plant_sapling.yaml      # Skill for replanting saplings for renewable wood loops
│   │   └── refill_water_tanks.yaml # Skill for keeping water tanks / boilers topped up
│   ├── skills_candidates           # Parking lot for WIP/draft skills not yet wired into the registry
│   ├── tools                       # Small config-related utilities & CLIs
│   │   ├── print_env.py            # Utility: pretty-print current EnvProfile for debugging
│   │   └── validate_env.py         # Phase 0 check: validates env + hardware + models + minecraft config
│   └── virtues.yaml                # Definition of the virtue lattice, weights, and constraint config
├── docs                            # Human-readable design docs for architecture and modules
│   ├── architecture.md             # High-level system architecture; modules, phases, data flow
│   ├── ipc_protocol_m6.md          # IPC message format/protocol between BotCore and external process
│   ├── m6_bot_core_1_7_10.md       # Detailed M6 BotCore design for GTNH 1.7.10 environment
│   └── phase1_integration.md       # Notes & decisions for integrating Phase 1 modules together
├── .github                         # CI / automation config for the repo
│   └── workflows                   # CI workflows definitions
│       └── ci.yml                  # Main CI pipeline: linting, tests, packaging, whatever you inflicted
├── .gitignore                      # Files/directories Git should pretend don’t exist
├── logs                            # Runtime logs (LLM + monitoring); you told me not to touch these lines
│   └── llm
│       ├── 20251127T154508_30389_error_model_analyze_failure.json
│       ├── 20251127T154508_30389_plan_code_plan.json
│       ├── 20251127T154508_30389_scribe_summarize_trace.json
│       ├── 20251127T154653_30421_plan_code_plan.json
│       ├── 20251127T154929_30485_error_model_analyze_failure.json
│       ├── 20251127T155054_30542_scribe_summarize_trace.json
│       ├── 20251127T171641_54578_plan_code_plan.json
│       ├── 20251127T172238_54966_plan_code_plan.json
│       ├── 20251127T172404_55071_plan_code_plan.json
│       ├── 20251127T181107_57121_plan_code_plan.json
│       ├── 20251127T181432_57416_plan_code_plan.json
│       ├── 20251127T202123_80866_error_model_analyze_failure.json
│       ├── 20251127T202123_80866_plan_code_plan.json
│       ├── 20251127T202123_80866_scribe_summarize_trace.json
│       ├── 20251127T202334_80953_error_model_analyze_failure.json
│       ├── 20251127T202334_80953_plan_code_plan.json
│       ├── 20251127T202334_80953_scribe_summarize_trace.json
│       ├── 20251127T223951_107281_error_model_analyze_failure.json
│       ├── 20251127T223951_107281_plan_code_plan.json
│       ├── 20251127T223951_107281_scribe_summarize_trace.json
│       ├── 20251128T001446_136742_error_model_analyze_failure.json
│       ├── 20251128T001446_136742_plan_code_plan.json
│       ├── 20251128T001446_136742_scribe_summarize_trace.json
│       ├── 20251128T003700_146815_error_model_analyze_failure.json
│       ├── 20251128T003700_146815_plan_code_plan.json
│       ├── 20251128T003700_146815_scribe_summarize_trace.json
│       ├── 20251128T115106_24456_error_model_analyze_failure.json
│       ├── 20251128T115106_24456_plan_code_plan.json
│       ├── 20251128T115106_24456_scribe_summarize_trace.json
│       ├── 20251128T143640_52852_error_model_analyze_failure.json
│       ├── 20251128T143640_52852_plan_code_plan.json
│       ├── 20251128T143640_52852_scribe_summarize_trace.json
│       ├── 20251128T143816_52937_error_model_analyze_failure.json
│       ├── 20251128T143816_52937_plan_code_plan.json
│       ├── 20251128T143816_52937_scribe_summarize_trace.json
│       ├── 20251128T153451_109564_error_model_analyze_failure.json
│       ├── 20251128T153451_109564_plan_code_plan.json
│       ├── 20251128T153451_109564_scribe_summarize_trace.json
│       ├── 20251128T154112_109913_error_model_analyze_failure.json
│       ├── 20251128T154112_109913_plan_code_plan.json
│       ├── 20251128T154112_109913_scribe_summarize_trace.json
│       ├── 20251128T154622_110074_error_model_analyze_failure.json
│       ├── 20251128T154622_110074_plan_code_plan.json
│       ├── 20251128T154622_110074_scribe_summarize_trace.json
│       ├── 20251128T155834_129265_error_model_analyze_failure.json
│       ├── 20251128T155834_129265_plan_code_plan.json
│       ├── 20251128T155834_129265_scribe_summarize_trace.json
│       ├── 20251128T160155_129475_error_model_analyze_failure.json
│       ├── 20251128T160155_129475_plan_code_plan.json
│       ├── 20251128T160155_129475_scribe_summarize_trace.json
│       ├── 20251128T160633_142703_error_model_analyze_failure.json
│       ├── 20251128T160633_142703_plan_code_plan.json
│       ├── 20251128T160633_142703_scribe_summarize_trace.json
│       ├── 20251128T162316_143085_error_model_analyze_failure.json
│       ├── 20251128T162316_143085_plan_code_plan.json
│       ├── 20251128T162316_143085_scribe_summarize_trace.json
│       ├── 20251128T162956_163507_error_model_analyze_failure.json
│       ├── 20251128T162956_163507_plan_code_plan.json
│       ├── 20251128T162956_163507_scribe_summarize_trace.json
│       ├── 20251128T164527_184688_error_model_analyze_failure.json
│       ├── 20251128T164527_184688_plan_code_plan.json
│       ├── 20251128T164527_184688_scribe_summarize_trace.json
│       ├── 20251128T164725_184780_error_model_analyze_failure.json
│       ├── 20251128T164725_184780_plan_code_plan.json
│       ├── 20251128T164725_184780_scribe_summarize_trace.json
│       ├── 20251128T164846_185052_error_model_analyze_failure.json
│       ├── 20251128T164846_185052_plan_code_plan.json
│       ├── 20251128T164846_185052_scribe_summarize_trace.json
│       ├── 20251128T190228_210275_error_model_analyze_failure.json
│       ├── 20251128T190228_210275_plan_code_plan.json
│       ├── 20251128T190228_210275_scribe_summarize_trace.json
│       ├── 20251128T190457_210363_error_model_analyze_failure.json
│       ├── 20251128T190457_210363_plan_code_plan.json
│       ├── 20251128T190457_210363_scribe_summarize_trace.json
│       ├── 20251128T191608_225560_error_model_analyze_failure.json
│       ├── 20251128T191608_225560_plan_code_plan.json
│       ├── 20251128T191608_225560_scribe_summarize_trace.json
│       ├── 20251128T192046_233385_error_model_analyze_failure.json
│       ├── 20251128T192046_233385_plan_code_plan.json
│       ├── 20251128T192046_233385_scribe_summarize_trace.json
│       ├── 20251128T192251_233478_error_model_analyze_failure.json
│       ├── 20251128T192251_233478_plan_code_plan.json
│       ├── 20251128T192251_233478_scribe_summarize_trace.json
│       ├── 20251128T204447_291001_error_model_analyze_failure.json
│       ├── 20251128T204447_291001_plan_code_plan.json
│       ├── 20251128T204501_291001_scribe_summarize_trace.json
│       ├── 20251128T204732_291164_error_model_analyze_failure.json
│       ├── 20251128T204732_291164_plan_code_plan.json
│       ├── 20251128T204807_291164_scribe_summarize_trace.json
│       ├── 20251128T212201_317178_error_model_analyze_failure.json
│       ├── 20251128T212201_317178_plan_code_plan.json
│       ├── 20251128T212258_317178_scribe_summarize_trace.json
│       ├── 20251128T214908_353050_error_model_analyze_failure.json
│       ├── 20251128T214908_353050_plan_code_plan.json
│       ├── 20251128T215005_353050_scribe_summarize_trace.json
│       ├── 20251128T215508_371511_error_model_analyze_failure.json
│       ├── 20251128T215508_371511_plan_code_plan.json
│       ├── 20251128T215605_371511_scribe_summarize_trace.json
│       ├── 20251128T215741_371600_error_model_analyze_failure.json
│       ├── 20251128T215741_371600_plan_code_plan.json
│       ├── 20251128T215838_371600_scribe_summarize_trace.json
│       ├── 20251129T120138_42538_error_model_analyze_failure.json
│       ├── 20251129T120138_42538_plan_code_plan.json
│       ├── 20251129T120235_42538_scribe_summarize_trace.json
│       ├── 20251129T121735_52787_error_model_analyze_failure.json
│       ├── 20251129T121735_52787_plan_code_plan.json
│       ├── 20251129T121832_52787_scribe_summarize_trace.json
│       ├── 20251129T122136_52946_error_model_analyze_failure.json
│       ├── 20251129T122136_52946_plan_code_plan.json
│       ├── 20251129T122233_52946_scribe_summarize_trace.json
│       ├── 20251129T131642_83734_error_model_analyze_failure.json
│       ├── 20251129T131642_83734_plan_code_plan.json
│       ├── 20251129T131738_83734_scribe_summarize_trace.json
│       ├── 20251129T131934_83828_error_model_analyze_failure.json
│       ├── 20251129T131934_83828_plan_code_plan.json
│       ├── 20251129T132032_83828_scribe_summarize_trace.json
│       ├── 20251129T134009_114623_error_model_analyze_failure.json
│       ├── 20251129T134009_114623_plan_code_plan.json
│       ├── 20251129T134106_114623_scribe_summarize_trace.json
│       ├── 20251129T135607_136708_error_model_analyze_failure.json
│       ├── 20251129T135607_136708_plan_code_plan.json
│       ├── 20251129T135703_136708_scribe_summarize_trace.json
│       ├── 20251129T140350_168767_error_model_analyze_failure.json
│       ├── 20251129T140350_168767_plan_code_plan.json
│       └── 20251129T140447_168767_scribe_summarize_trace.json
├── pyproject.toml                   # Project packaging config: dependencies, entrypoints, tool settings
├── .pytest_cache                    # Pytest’s hoard of run metadata; safe to nuke when it annoys you
│   ├── CACHEDIR.TAG                 # Tag so tools recognize this as a cache dir
│   ├── .gitignore                   # Ensures cache content is not committed
│   ├── README.md                    # Tiny explanation of pytest cache directory
│   └── v                            # Versioned cache entries
│       └── cache                    # Actual cached test run data
│           ├── lastfailed           # Map of last failed tests for `pytest --last-failed`
│           └── nodeids              # Cached list of test node IDs
├── .python-version                  # Python version pinning for tools like pyenv
├── README.md                        # Top-level project overview, usage & goals
├── scripts                          # One-off / maintenance / dev scripts outside the main package
│   ├── compact_recipes_for_agent.py # Script to compact raw recipes into agent-friendly JSON
│   ├── demo_offline_agent_step.py   # Demo: run a single offline agent step without Minecraft
│   ├── dev_shell.py                 # Convenience shell launcher with env pre-wired
│   ├── ingest_gtnh_semantics.py     # Pipeline: turn GTNH dumps into semantic YAML/JSON
│   ├── ingest_nerd_csv_semantics.py # Import semantics from nerd CSV dumps into structured form
│   ├── ingest_nerd_recipes.py       # Build recipe graphs from nerd-powered dumps
│   ├── smoke_error_model.py         # Quick sanity check for error-model LLM behavior
│   ├── smoke_llm_stack.py           # Sanity test: bring up LLM stack and run basic calls
│   └── smoke_scribe_model.py        # Sanity test for the scribe/summary model
├── src                              # Main Python package source for GTNH_Agent
│   ├── agent                        # Early agent wiring / legacy runtime helpers (Phase 1-ish glue)
│   │   ├── bootstrap.py             # Bootstrap helpers to wire M2–M5 for offline demos
│   │   ├── experience.py            # Experience/episode representation for earlier agent flows
│   │   ├── logging_config.py        # Logging configuration defaults for the older agent entrypoints
│   │   ├── loop.py                  # Legacy agent loop before AgentLoopV1 became the main path
│   │   └── runtime_m6_m7.py         # Runtime bridging early M6/M7 with the legacy agent stack
│   ├── agent_loop                   # M8 core: new AgentLoop implementation + state/schema
│   │   ├── __init__.py              # Package init for agent_loop (exports AgentLoopV1 etc.)
│   │   ├── loop.py                  # AgentLoopV1: main high-level control loop
│   │   ├── schema.py                # Typed structures for plans, traces, phases, etc.
│   │   └── state.py                 # AgentLoop internal state machine / phase abstractions
│   ├── app                          # High-level app entrypoints (CLIs, app-level wiring)
│   │   ├── __init__.py              # Package marker for app
│   │   └── runtime.py               # App-level runtime that likely calls into runtime/bootstrap
│   ├── bot_core                     # M6: BotCore implementation for Minecraft IO + navigation
│   │   ├── actions.py               # High-level action implementations (move, click, use, etc.)
│   │   ├── collision.py             # Collision and hitbox logic for movement/pathfinding
│   │   ├── core.py                  # Main BotCore orchestration and public interface
│   │   ├── __init__.py              # Package init for bot_core
│   │   ├── nav                      # Navigation subsystem: grid/pathfinding/movement
│   │   │   ├── grid.py              # Grid representation / discretization of world space
│   │   │   ├── __init__.py          # Package init for nav
│   │   │   ├── mover.py             # Movement controller that steps the bot along paths
│   │   │   └── pathfinder.py        # Pathfinding algorithms (A*, cost models, etc.)
│   │   ├── net                      # Networking / IPC layer for communication with Minecraft
│   │   │   ├── client.py            # Native client implementation for internal BotCore usage
│   │   │   ├── external_client.py   # IPC-based client for external/remote BotCore control
│   │   │   ├── __init__.py          # Package init for net
│   │   │   └── ipc.py               # IPC protocol implementation for M6 <-> game bridge
│   │   ├── runtime.py               # BotCore runtime entrypoints / boot helpers
│   │   ├── snapshot.py              # World snapshot structures and diff helpers
│   │   ├── testing                  # BotCore-specific test fakes and utilities
│   │   │   └── fakes.py             # Fake BotCore implementations for tests
│   │   ├── tracing.py               # Internal tracing/instrumentation for BotCore operations
│   │   └── world_tracker.py         # Tracks world state over time from observations
│   ├── cli                          # Command-line utilities wiring phases together
│   │   └── phase1_offline.py        # CLI to run Phase 1 offline planning/LLM demos
│   ├── curriculum                   # Curriculum engine for long-horizon learning / planning
│   │   ├── engine.py                # Curriculum selection and progression logic
│   │   ├── __init__.py              # Package init for curriculum
│   │   ├── loader.py                # Load curricula from config/curricula
│   │   └── schema.py                # Typed schema for curriculum definitions
│   ├── env                          # Environment loading/runtime profile (M0 runtime side)
│   │   ├── __init__.py              # Package init for env
│   │   ├── loader.py                # load_env_profile implementation used across runtime/tests
│   │   └── schema.py                # Pydantic/dataclass schema for EnvProfile and related structs
│   ├── gtnh_agent.egg-info          # Packaging metadata for the installed distribution
│   │   ├── dependency_links.txt     # Dependencies metadata for setuptools
│   │   ├── PKG-INFO                 # Package metadata blob generated by build tools
│   │   ├── requires.txt             # Runtime dependency pins for the built package
│   │   ├── SOURCES.txt              # List of source files included in the package
│   │   └── top_level.txt            # Top-level packages exposed by this distribution
│   ├── __init__.py                  # Top-level src package init; may expose key APIs
│   ├── integration                  # Glue code tying modules & phases together
│   │   ├── adapters                 # Adapters to translate between module-specific representations
│   │   │   └── m0_env_to_world.py   # Adapter: convert EnvProfile configs into world assumptions
│   │   ├── episode_logging.py       # Higher-level episode logging utilities beyond raw monitoring
│   │   ├── __init__.py              # Package init for integration
│   │   ├── phase1_integration.py    # Integration code specifically for Phase 1 modules
│   │   ├── testing                  # Integration-level test helpers and fakes
│   │   │   ├── fakes.py             # Fakes for integration tests (fake env, fake stacks, etc.)
│   │   │   └── __init__.py          # Package init for integration.testing
│   │   └── validators               # Cross-module validation utilities
│   │       ├── __init__.py          # Package init for validators
│   │       ├── planner_guardrails.py# Validations/safety checks on planner outputs
│   │       ├── semantics_snapshots.py# Snapshot-based sanity checks on semantics
│   │       ├── skill_integrity.py   # Consistency checks for skills vs. semantics/curricula
│   │       └── virtue_snapshots.py  # Sanity checks for virtue scoring and configs
│   ├── learning                     # Future-facing learning / experience replay layer
│   │   ├── buffer.py                # Experience buffer / replay store
│   │   ├── evaluator.py             # Evaluation of policies/agents over tasks
│   │   ├── __init__.py              # Package init for learning
│   │   ├── manager.py               # Orchestrator for learning runs
│   │   ├── schema.py                # Typed schema for experiences, batches, etc.
│   │   └── synthesizer.py           # Synthetic data / trace generator for training
│   ├── llm_stack                    # M2: LLM stack abstraction and components
│   │   ├── backend_llamacpp.py      # Llama.cpp backend integration for local models
│   │   ├── backend.py               # Abstract interface for LLM backends
│   │   ├── codegen.py               # Helpers for code generation-style tasks
│   │   ├── config.py                # LLM stack configuration helpers
│   │   ├── critic.py                # Critic LLM interface & orchestration glue
│   │   ├── error_model.py           # Error-model LLM wrapper for plan critique/failure analysis
│   │   ├── __init__.py              # Package init for llm_stack
│   │   ├── json_utils.py            # Robust JSON parsing/repair helpers for LLM outputs
│   │   ├── log_files.py             # Handling of llm-specific log file structures
│   │   ├── plan_code.py             # Planner+codegen fusion interface for code-style planning
│   │   ├── planner.py               # High-level planner LLM client
│   │   ├── presets.py               # Prompt/role presets for planner/critic/scribe/error-model
│   │   ├── schema.py                # Typed request/response schema for LLM calls
│   │   ├── scribe.py                # Scribe LLM client for summaries, traces, notes
│   │   └── stack.py                 # Factory to assemble a full LLM stack from config
│   ├── monitoring                   # M9: monitoring & tools layer (HUD, logging, controller)
│   │   ├── bus.py                   # Thread-safe EventBus implementation for MonitoringEvents
│   │   ├── controller.py            # AgentController for pause/resume/step/goal/cancel/dump-state
│   │   ├── dashboard_tui.py         # rich-based TUI HUD subscribing to monitoring events
│   │   ├── events.py                # EventType enum and MonitoringEvent/ControlCommand schemas
│   │   ├── __init__.py              # Package init for monitoring
│   │   ├── integration.py           # Helper functions emit_* for common event patterns (plans, phases, etc.)
│   │   ├── llm_logging.py           # LLM-specific JSON log writer (logs/llm/*.json)
│   │   ├── logger.py                # JsonFileLogger + log_event helper for monitoring events
│   │   └── tools.py                 # Human tools: episode inspector, LLM log viewer, CLI helpers
│   ├── observation                  # M7: observation encoding & trace structures
│   │   ├── encoder.py               # Core encoder turning world state into planner/critic payloads
│   │   ├── __init__.py              # Package init for observation
│   │   ├── pipeline.py              # End-to-end observation pipeline orchestration
│   │   ├── schema.py                # Typed schemas for observations and planner payloads
│   │   ├── testing.py               # Utilities and fixtures for observation tests
│   │   └── trace_schema.py          # Schema for execution traces and their steps
│   ├── runtime                      # Phase 3+: unified runtime entrypoints & failure handling
│   │   ├── agent_runtime_main.py    # Runtime wiring M8 + M9: one agent loop + HUD + controller
│   │   ├── bootstrap_phases.py      # Conceptual bootstrap tying Phases 0–3 into run_full_system()
│   │   ├── error_handling.py        # safe_step_with_logging: logs AGENT_STEP_EXCEPTION events
│   │   ├── failure_mitigation.py    # Helpers to log config/LLM/action/monitoring failures consistently
│   │   └── __init__.py              # Package init for runtime
│   ├── semantics                    # M3: GTNH world semantics and tech graph
│   │   ├── cache.py                 # Caching layer for semantics lookups
│   │   ├── categorize.py            # Grouping items/blocks into semantic categories
│   │   ├── crafting.py              # Craftability / recipe reasoning helpers
│   │   ├── ingest                   # Code related to importing raw GTNH data into semantics
│   │   │   └── __init__.py          # Package init for semantics.ingest
│   │   ├── __init__.py              # Package init for semantics
│   │   ├── loader.py                # Load semantic data from config/gtnh_* files
│   │   ├── schema.py                # Schema for items, blocks, recipes, and tech-state structures
│   │   └── tech_state.py            # TechState inference engine (tier + missing unlocks)
│   ├── skills                       # M5: skills system implementation
│   │   ├── base                     # Concrete skill implementations for basic GTNH tasks
│   │   │   ├── basic_crafting.py    # Runtime implementation of basic_crafting skill
│   │   │   ├── chop_tree.py         # Runtime implementation of chop_tree skill
│   │   │   ├── feed_coke_ovens.py   # Runtime implementation of feed_coke_ovens skill
│   │   │   ├── feed_steam_boiler.py # Runtime implementation of feed_steam_boiler skill
│   │   │   ├── __init__.py          # Package init for skills.base
│   │   │   ├── maintain_coke_ovens.py# Runtime implementation of maintain_coke_ovens skill
│   │   │   ├── plant_sapling.py     # Runtime implementation of plant_sapling skill
│   │   │   └── refill_water_tanks.py# Runtime implementation of refill_water_tanks skill
│   │   ├── __init__.py              # Package init for skills
│   │   ├── loader.py                # Load skill configs from config/skills & skill_packs
│   │   ├── packs.py                 # Logic for combining skills into packs (steam_age, lv_core, etc.)
│   │   ├── registry.py              # Central registry of available skills for planning
│   │   └── schema.py                # Schema for skill definitions and instances
│   ├── spec                         # Specification layer: protocols/types the implementation must satisfy
│   │   ├── agent_loop.py            # Spec for AgentLoop interface & expectations
│   │   ├── bot_core.py              # Spec for BotCore interface and behavior
│   │   ├── experience.py            # Spec for experience/episode representations
│   │   ├── __init__.py              # Package init for spec
│   │   ├── llm.py                   # Spec for LLM stack interfaces
│   │   ├── skills.py                # Spec for skills & curriculum contracts
│   │   └── types.py                 # Shared type aliases / protocol definitions
│   ├── testing                      # Shared testing utilities for src
│   │   └── __init__.py              # Package init for testing helpers
│   └── virtues                      # M4: virtue lattice, scoring, and sanity checks
│       ├── explain.py               # Human-readable explanations of virtue evaluations
│       ├── features.py              # Feature extraction for virtue scoring
│       ├── __init__.py              # Package init for virtues
│       ├── lattice.py               # Structure of the virtue lattice & relationships
│       ├── loader.py                # Load virtue config from config/virtues.yaml
│       ├── metrics.py               # Metrics & scoring functions over plans/traces
│       ├── sanity.py                # Sanity checks for virtue config and behavior
│       └── schema.py                # Typed schema for virtue configuration and results
├── tests                            # Test suite: unit + integration coverage across phases
│   ├── conftest.py                  # Shared pytest fixtures & configuration
│   ├── fakes                        # Fake implementations used across test modules
│   │   ├── fake_bot_core.py         # Fake BotCore for tests (no real Minecraft)
│   │   ├── fake_llm_stack.py        # Fake LLM stack for deterministic tests
│   │   ├── fake_runtime.py          # Fake runtime wiring for full-system simulations
│   │   ├── fake_skills.py           # Fake skills registry and implementations
│   │   └── __init__.py              # Package init for tests.fakes
│   ├── __init__.py                  # Package init so tests can be imported as a module
│   ├── test_actions.py              # Tests for BotCore actions and side effects
│   ├── test_agent_loop_stub.py      # Tests for stubbed/early AgentLoop behavior
│   ├── test_agent_loop_v1.py        # Tests for AgentLoopV1 core logic and phases
│   ├── test_architecture_integration.py # High-level architecture consistency checks
│   ├── test_bot_core_impl.py        # Tests for concrete BotCore implementation details
│   ├── test_env_loader.py           # M0 tests for EnvProfile loading/validation
│   ├── test_error_model_with_fake_backend.py # Error-model behavior with fake backend
│   ├── test_failure_mitigation.py   # Tests for runtime.failure_mitigation helpers
│   ├── test_full_system_smoke.py    # Cross-phase smoke test using fake agent loop + monitoring
│   ├── test_llm_stack_fake_backend.py# LLM stack tests using fake backend (no GPU needed)
│   ├── test_m6_observe_contract.py  # Contract tests for BotCore observation behavior
│   ├── test_monitoring_controller.py# Tests for AgentController pause/step/goal/cancel/dump logic
│   ├── test_monitoring_dashboard_tui.py # TUI dashboard smoke tests
│   ├── test_monitoring_event_bus.py # EventBus publish/subscribe semantics & ordering
│   ├── test_monitoring_logger.py    # JsonFileLogger structure & behavior tests
│   ├── test_nav_pathfinder.py       # Pathfinding correctness and edge cases
│   ├── test_observation_critic_encoding.py # Encoding for critic-specific payloads
│   ├── test_observation_perf.py     # Performance tests for observation pipeline
│   ├── test_observation_pipeline.py # End-to-end tests for observation pipeline
│   ├── test_observation_planner_encoding.py # Planner encoding correctness
│   ├── test_observation_worldstate_normalization.py # Normalization of raw worldstate inputs
│   ├── test_p0_p1_env_bridge.py     # Tests bridging Phase 0 env → Phase 1 components
│   ├── test_phase012_bootstrap.py   # Bootstrap tests for Phases 0–2 integration
│   ├── test_phase0_runtime.py       # Runtime tests specifically focused on Phase 0 behavior
│   ├── test_phase1_breakglass_no_plans.py # Behavior when planner produces no viable plans
│   ├── test_phase1_integration_offline.py # Offline integration tests for Phase 1
│   ├── test_runtime_integration.py  # Integration tests for runtime + monitoring + fake AgentLoop
│   ├── test_runtime_m6_m7_smoke.py  # Smoke tests for runtime wiring BotCore + observation
│   ├── test_scribe_model_with_fake_backend.py # Scribe LLM tests with fake backend
│   ├── test_semantics_caching_singleton.py # Semantics caching / singleton behavior tests
│   ├── test_semantics_categorization.py # Item/block categorization tests
│   ├── test_semantics_craftability.py # Craftability reasoning tests
│   ├── test_semantics_tech_inference.py # TechState inference tests
│   ├── test_semantics_tolerant_fallbacks.py # Robustness of semantics when data missing/bad
│   ├── test_semantics_with_normalized_worldstate.py # Semantics behavior under normalized worldstate
│   ├── test_skill_loader.py         # Skill loader correctness tests
│   ├── test_skill_packs_integrity.py# Validate skill packs consistency vs config
│   ├── test_skill_packs.py          # Tests for pack selection/behavior
│   ├── test_skill_registry.py       # SkillRegistry behavior & lookup tests
│   ├── test_virtue_compare_plans.py # Virtue-based comparison of alternative plans
│   ├── test_virtue_config_sanity.py # Virtue config sanity checks
│   ├── test_virtue_hard_constraints.py # Tests for hard virtue constraints enforcement
│   ├── test_virtue_lattice_basic.py # Basic virtue lattice structure/logic tests
│   └── test_world_tracker.py        # Tests for BotCore world tracking over time
└── tools                           # User-facing demo tools / thin frontends
    ├── agent_demo.py               # Demo script exercising the agent in a simple scenario
    ├── phase1_demo.py              # Demo focusing on Phase 1 (planning/semantics/virtues) offline
    └── smoke_botcore.py            # Quick BotCore smoke test using actual or fake Minecraft connection

```



## GTNH_Agent – Phase 0–3 State of the Union

**Focus:** What exists now, what it does, and what M10 should build on.

---

## 1. Where we are

**Completed phases**

- **Phase 0**: Environment foundation (M0, M1)
    
- **Phase 1**: Cognition & knowledge (M2–M5)
    
- **Phase 2**: Body & perception (M6, M7)
    
- **Phase 3**: Agency & monitoring (M8, M9)
    

**Big picture:**  
You now have:

- A **validated runtime environment** (`EnvProfile`)
    
- A **modular LLM stack**
    
- A **GTNH semantic world model & TechState engine**
    
- A **virtue lattice for evaluating plans**
    
- A **skill system + curricula**
    
- A **BotCore** that can act in the world & observe it
    
- An **AgentLoopV1** orchestrating observe → plan → act → critique
    
- A **monitoring layer (M9)** that turns everything into events, logs, and a TUI HUD
    
- A **runtime bootstrap** that wires Phases 0–3 together with tests all green
    

M10 now sits on top of all this: it’s where “experience memory” and learning stop being vibes and become a concrete artifact.

---

## 2. Core components & definitions (by phase)

### Phase 0 – Foundations (M0, M1)

**Env loader & validation**

- `config/env.yaml`, `hardware.yaml`, `minecraft.yaml`, `models.yaml` → loaded into an `EnvProfile`.
    
- `src/env/loader.py` & `src/env/schema.py` define this profile.
    
- `config/tools/validate_env.py` + `tests/test_env_loader.py` + `test_phase0_runtime.py` ensure:
    
    - Configs exist & parse
        
    - Minecraft host/port & IPC config are sane
        
    - Model paths actually exist on disk
        

**What this gives you:**  
A single source of truth for “how & where the agent runs.”

---

### Phase 1 – Mind & knowledge (M2–M5)

**M2 – LLM Stack (`src/llm_stack/`)**

- Roles: planner, critic, scribe, error_model, etc.
    
- Backends: `backend_llamacpp.py` etc.
    
- Schema / presets / config: `schema.py`, `presets.py`, `config.py`.
    
- Tests: `test_llm_stack_fake_backend.py`, `test_error_model_with_fake_backend.py`, `test_scribe_model_with_fake_backend.py`.
    

**M3 – Semantics & TechState (`src/semantics/` + `config/gtnh_*`)**

- Loads GTNH items, blocks, recipes, and tech graph from:
    
    - `gtnh_items*.yaml`, `gtnh_blocks*.yaml`, `gtnh_recipes*.json`, `gtnh_tech_graph.yaml`.
        
- `tech_state.py` infers:
    
    - Current tier
        
    - Missing unlocks
        
    - What’s craftable given base state
        
- Tests: `test_semantics_*`, `test_semantics_tech_inference.py`, `test_semantics_craftability.py`.
    

**M4 – Virtues (`src/virtues/` + `config/virtues.yaml`)**

- Virtue lattice defining moral / functional constraints.
    
- Metrics & sanity checks over plans: `metrics.py`, `sanity.py`, `virtue_snapshots` tests.
    
- Tests: `test_virtue_*`.
    

**M5 – Skills & Curriculum**

- Skills config in `config/skills/*.yaml` & packs in `config/skill_packs/`.
    
- Implementation in `src/skills/`:
    
    - `base/` = concrete skills
        
    - `loader.py` / `registry.py` / `packs.py` glue everything.
        
- Curriculum engine in `src/curriculum/`:
    
    - `engine.py`, `loader.py`, `schema.py`
        
    - Uses `config/curricula/*.yaml`
        

**What this gives you:**  
A structured **thinking stack**: LLMs, world understanding, ethical scoring, and symbolic skills.

---

### Phase 2 – Body & perception (M6, M7)

**M6 – BotCore (`src/bot_core/`)**

- **Actions:** `actions.py` – movement, interactions, block use, etc.
    
- **Navigation:** `nav/grid.py`, `nav/pathfinder.py`, `nav/mover.py`.
    
- **Networking / IPC:** `net/client.py`, `net/external_client.py`, `net/ipc.py`.
    
- **World snapshots & tracking:** `snapshot.py`, `world_tracker.py`.
    
- Tests: `test_bot_core_impl.py`, `test_nav_pathfinder.py`, `test_world_tracker.py`, `test_m6_observe_contract.py`.
    

**M7 – Observation (`src/observation/`)**

- `encoder.py` / `pipeline.py`:  
    Convert `WorldState` + semantics + TechState into:
    
    - Planner payloads
        
    - Critic payloads
        
    - Trace structures
        
- `trace_schema.py`, `schema.py`: typed structures for observations & traces.
    
- Tests: `test_observation_*` suite.
    

**What this gives you:**  
A fully wired **body & senses**: the agent can **see** the world in structured form and **act** on it.

---

### Phase 3 – Agency & monitoring (M8, M9)

#### M8 – AgentLoop (`src/agent_loop/`)

- `loop.py` (AgentLoopV1), `schema.py`, `state.py`:
    
    - Orchestrate `observe → plan → act → critique → log experience`.
        
    - Uses:
        
        - EnvProfile
            
        - LLM stack
            
        - TechState engine
            
        - Virtue engine
            
        - Skill registry
            
        - BotCore
            
        - Observation encoder
            
        - Monitoring bus / integration helpers
            
- Tests:
    
    - `test_agent_loop_v1.py`
        
    - `test_agent_loop_stub.py`
        
    - `test_architecture_integration.py`
        
    - `test_phase012_bootstrap.py`
        
    - `test_phase1_integration_offline.py`
        
    - `test_runtime_m6_m7_smoke.py`
        
    - `test_runtime_integration.py`
        

#### M9 – Monitoring & Tools (`src/monitoring/` + `src/runtime/`)

**Core concepts**

- **Event bus (`monitoring.bus.EventBus`)**
    
    - Thread-safe pub/sub for:
        
        - `MonitoringEvent`
            
        - `ControlCommand`
            
    - Used by:
        
        - AgentLoop
            
        - BotCore
            
        - Observation
            
        - Virtues
            
        - Runtime
            
        - TUI
            
        - Logger
            
        - Tools / CLI
            
- **Events model (`monitoring.events`)**
    
    - `EventType` includes:
        
        - `AGENT_PHASE_CHANGE`
            
        - `PLAN_CREATED`
            
        - `PLAN_STEP_EXECUTED`
            
        - `ACTION_EXECUTED`
            
        - `PLAN_FAILED`
            
        - `TECH_STATE_UPDATED`
            
        - `VIRTUE_SCORES`
            
        - `CRITIC_RESULT`
            
        - `SNAPSHOT`
            
        - `CONTROL_COMMAND`
            
        - `LOG`
            
    - Payloads carry:
        
        - `timestamp`, `module`, `event_type`
            
        - `message`, `payload`, `correlation_id` (e.g. `episode_id`)
            
- **Control commands**
    
    - Types:
        
        - `PAUSE`, `RESUME`, `SINGLE_STEP`, `CANCEL_PLAN`, `SET_GOAL`, `DUMP_STATE`
            
    - Consumed by `AgentController`, produced by:
        
        - CLI tools
            
        - Future monitoring CLI
            
        - Debug scripts
            

**Monitoring spine**

- `monitoring.logger.JsonFileLogger`
    
    - Subscribes to EventBus
        
    - Writes **one JSON line per MonitoringEvent**
        
    - Default: `logs/monitoring/events.log`
        
- `monitoring.logger.log_event`
    
    - Convenience helper to produce properly structured events everywhere
        

**Control surface**

- `monitoring.controller.AgentController`
    
    - Wraps AgentLoopV1 with:
        
        - `pause/resume`
            
        - `single-step`
            
        - `cancel_current_plan`
            
        - `set_goal`
            
        - `dump_state` (emits `SNAPSHOT` with debug_state payload)
            
    - Listens on EventBus for `ControlCommand`s
        
    - Tested by `test_monitoring_controller.py`
        

**TUI dashboard**

- `monitoring.dashboard_tui.TuiDashboard`
    
    - Subscribes to EventBus
        
    - Shows:
        
        - Phase
            
        - Current goal
            
        - Plan summary
            
        - TechState snapshot
            
        - Virtue scores
            
    - Uses `rich` in a background thread
        
    - Tests: `test_monitoring_dashboard_tui.py` (smoke)
        

**LLM logging**

- `monitoring.llm_logging.LLMLogWriter` + `log_llm_call`
    
    - Writes one JSON file per LLM call to `logs/llm/*.json`
        
    - Schema: timestamp, role, model, prompt, response, token counts, meta
        
    - Used by LLM stack clients for deeper introspection
        

**Runtime integration**

- `src/runtime/agent_runtime_main.py`
    
    - Wires:
        
        - EventBus
            
        - JsonFileLogger
            
        - AgentLoopV1
            
        - AgentController
            
        - TuiDashboard
            
    - Drives main loop via `controller.maybe_step_agent()`.
        
- `src/runtime/bootstrap_phases.py`
    
    - Conceptual **Phase 0–3 bootstrap**:
        
        - Phase 0: `bootstrap_phase0` → load & validate env
            
        - Phase 1: `bootstrap_phase1` → build LLM stack, semantics, virtues, skills
            
        - Phase 2: `bootstrap_phase2` → BotCore + ObservationEncoder
            
        - Phase 3:
            
            - `build_monitoring_stack` → EventBus + JsonFileLogger + TUI
                
            - `bootstrap_phase3` → AgentLoopV1 + AgentController
                
        - `run_full_system(config_root)` → unified runtime loop
            

**Failure handling**

- `src/runtime/error_handling.py`
    
    - `safe_step_with_logging(controller, bus, episode_id, context_id)`:
        
        - Wraps `controller.maybe_step_agent()`
            
        - On exception:
            
            - Emits `LOG` event with subtype `"AGENT_STEP_EXCEPTION"`
                
            - Re-raises so caller can decide what to do
                
- `src/runtime/failure_mitigation.py`
    
    - Helpers to turn failures into structured events:
        
        - `emit_config_error`
            
        - `emit_model_path_error`
            
        - `emit_llm_failure` (`LLM_TIMEOUT`, `LLM_BAD_OUTPUT`, etc.)
            
        - `emit_action_failure` (`ACTION_EXECUTED` with `success=False`)
            
        - `emit_plan_failed_due_to_actions` (`PLAN_FAILED` escalation)
            
        - `emit_monitoring_overload_warning`
            
    - Tested by `test_failure_mitigation.py`
        

**Cross-phase smoke test**

- `tests/test_full_system_smoke.py`
    
    - Uses:
        
        - Real `EventBus` + `JsonFileLogger`
            
        - `AgentController` + `FakeAgentLoop`
            
        - `safe_step_with_logging`
            
    - Verifies:
        
        - Logs are written
            
        - Episode events form coherent sequence (`AGENT_PHASE_CHANGE`, `PLAN_CREATED`, `PLAN_STEP_EXECUTED`)
            
        - `correlation_id` stays consistent
            

**Key insight:**  
M9 is a **completely GTNH-agnostic monitoring layer**. All GTNH weirdness stays in semantics, skills, and BotCore. Monitoring is just structured events.

---

## 3. Design patterns & insights

1. **Single monitoring spine**
    
    - Everything interesting produces `MonitoringEvent`s.
        
    - Consumers (TUI, episode inspector, tools) never reach into internals; they just read events & logs.
        
2. **Event-first architecture**
    
    - AgentLoop, BotCore, Virtues, Semantics produce events.
        
    - Runtime and tools react to events.
        
    - This makes recording, replay, and debugging much easier.
        
3. **Strict separation: control vs. behavior**
    
    - AgentLoop controls logic.
        
    - AgentController controls _whether_ and _how_ stepping happens.
        
    - Monitoring only observes; it never pushes game logic.
        
4. **Failure is a first-class citizen**
    
    - Config, model, LLM, action, plan, and runtime failures all have structured event types.
        
    - Nothing silently dies without at least shouting into `events.log`.
        
5. **Tests as architecture glue**
    
    - Phase-specific tests validate modules in isolation.
        
    - Integration tests (`test_runtime_integration.py`, `test_full_system_smoke.py`, `test_phase012_bootstrap.py`) assert that wiring actually works.
        

---

## 4. Phase 4 / M10 – What’s next

M10 is basically:  
**“Turn all of this into experience memory and an actual learning substrate.”**

### 4.1 M10 mission

Build the **Experience & Learning layer** that:

- Consumes:
    
    - Monitoring events (`events.log`)
        
    - LLM logs (`logs/llm/*.json`)
        
    - AgentLoop traces (via observation/trace schema)
        
- Produces:
    
    - Structured **experiences / episodes** stored in `src/learning/*`
        
    - A replay buffer / manager that can feed:
        
        - Offline analysis tools
            
        - Curriculum engine
            
        - Future training loops (RL, imitation, heuristics, etc.)
            

Think: “ARC-like trace buffer for GTNH agent behavior.”

---

### 4.2 Existing M10 scaffolding

You already have `src/learning/`:

- `buffer.py` – replay buffer scaffold
    
- `schema.py` – experience schema skeleton
    
- `manager.py` – learning orchestration
    
- `evaluator.py` – evaluation logic
    
- `synthesizer.py` – synthetic example generation
    

M10’s job is to actually **hook these to reality**:

- Tie buffer/schema to real events from M8/M9.
    
- Make manager/evaluator operate on real episodes.
    
- Make synthesizer use concrete GTNH traces instead of hypothetical ones.
    

---

### 4.3 M10 design targets

**1. Experience schema**

Define a concrete `Experience` / `Episode` model (in `learning.schema`) that includes:

- IDs:
    
    - `episode_id`
        
    - `context_id`
        
- High-level metadata:
    
    - world / env profile
        
    - tech tier at start & end
        
    - goal text
        
    - curriculum slice / skill pack
        
- Plan-level data:
    
    - final plan
        
    - per-step results
        
    - virtue scores (per plan / per step)
        
    - critic verdicts
        
- Trace:
    
    - sequence of `PLAN_STEP_EXECUTED` + `ACTION_EXECUTED` + `SNAPSHOT` events
        
- LLM context:
    
    - references to `logs/llm/*.json` entries used in this episode
        
- Outcome:
    
    - success/failure
        
    - failure reason (if any)
        
    - key metrics (time, steps, resource changes)
        

**2. Episode recorder**

New component (probably in `integration/episode_logging.py` or `learning/manager.py`):

- Subscribes to EventBus (or reads from `events.log`).
    
- Aggregates events by `episode_id` (via `correlation_id`).
    
- Builds complete `Episode` objects according to the schema.
    
- Writes them to:
    
    - `logs/episodes/*.jsonl` or
        
    - A simple replay DB managed by `learning.buffer`.
        

**3. Replay buffer**

Extend `learning.buffer` so that it can:

- Append new episodes as they finish.
    
- Sample:
    
    - Random episodes
        
    - Episodes by tech tier / curriculum unit / outcome type
        
- Export:
    
    - Datasets for external training
        
    - Input to `learning.evaluator` and `learning.synthesizer`.
        

**4. Integration with runtime**

Wire M10 into runtime:

- In `runtime/agent_runtime_main.py` or `bootstrap_phases.py`:
    
    - Construct an `EpisodeRecorder` or `ExperienceManager` that:
        
        - Subscribes to EventBus
            
        - Saves episodes when the loop signals episode boundaries (via some event or AgentLoop hook).
            

**5. Tools for humans**

Extend `monitoring.tools` / new `learning.tools` to:

- List episodes by:
    
    - time, tech tier, success/failure, goal substring
        
- Show a compact episode summary:
    
    - goal, result, key stats, virtue scores
        
- Optionally dump a single episode as JSON for external analysis.
    

---

### 4.4 Concrete next steps for M10

Minimum viable M10, in order:

1. **Finalize experience schema**
    
    - Flesh out `learning.schema.Experience` / `Episode`.
        
    - Align fields with:
        
        - `MonitoringEvent` types
            
        - `AgentLoop` plan/trace schema
            
        - Virtue & TechState payloads.
            
2. **Build EpisodeRecorder**
    
    - New class that:
        
        - Listens on EventBus OR replays `events.log`.
            
        - Aggregates per-episode event streams.
            
        - Produces `Episode` objects.
            
3. **Integrate with learning.buffer**
    
    - Implement:
        
        - `append(episode)`
            
        - `sample(...)`
            
    - Store episodes in a simple on-disk format (JSONL or small pickles; keep it boring and robust).
        
4. **Wire into runtime**
    
    - In `run_full_system`, construct recorder/buffer.
        
    - Ensure:
        
        - Episode boundaries are clearly defined (by AgentLoop).
            
        - Episodes actually flush to disk when completed.
            
5. **Tests**
    
    - `test_learning_schema_experience.py`:
        
        - Roundtrip JSON ↔ dataclass.
            
    - `test_episode_recorder_from_events.py`:
        
        - Feed synthetic MonitoringEvents; assert output `Episode` matches expectations.
            
    - `test_replay_buffer_sampling.py`:
        
        - Append multiple episodes; sample by filters; ensure deterministic behavior.
            
6. **Developer tools**
    
    - Add a small CLI in `tools/`:
        
        - `episode_inspect.py` – show a summary of last N episodes.
            
    - Optional: hook this into `monitoring.tools` for a unified interface.
        

---

### TL;DR for future you

- Phases 0–3 are **operational** and integrated:
    
    - Env, LLMs, semantics, virtues, skills, BotCore, Observation, AgentLoop, Monitoring, Runtime.
        
- M9 gave you:
    
    - A **universal event stream**, **JSONL logs**, a **TUI HUD**, and **structured failure reporting**.
        
- **M10’s job** is to:
    
    - Turn that event stream into **experience memory**.
        
    - Provide a replay layer so future training / optimization isn’t glued to live play.
        

So the next move is not “more mechanics,” it’s:  
**teach the system how to remember what it did, why it did it, and how badly it failed.**